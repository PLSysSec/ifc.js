\section{Introduction}
\label{sec:intro}

Modern web content is rendered using a potentially large number of
different components with differing provenance.
Disparate and untrusting components may arise from browser
extensions (whose JavaScript code runs alongside website
code), web applications (with possibly untrusted third-party
libraries), and mashups (which combine code and data from
websites that may not even be aware of each other's existence.)
While just-in-time combination of untrusting components
offers great flexibility, it also poses complex security challenges.
In particular, maintaining data privacy in the face of malicious
extensions, libraries, and mashup components has been difficult,
and in general effectively impossible.

Information flow control (IFC) is a promising technique
that provides security
by tracking the flow of sensitive data through a system.
Untrusted code is confined so that it cannot exfiltrate data, except as
per an information flow policy.  Significant research has been devoted to
adding various forms of IFC to different kinds of programming languages
and systems.  In the context of the web, however, there is a strong
motivation to preserve the language JavaScript, and retrofit dynamic information
flow control on top of it.  A key challenge in dynamic information
flow control is implementation efficiency: when
information flow is tracked at a fine-grained level,
e.g., per value in the system, systems may incur
impractical runtime overhead~\cite{JSFlow}.
%
Moreover, the task of adding fine-grained IFC even to a simple language is
non-trivial~\cite{hritcu2013testing}; when considering a real-world language,
such as JavaScript, this challenge becomes almost insurmountable.


In the alternative \textit{coarse-grained} approach to IFC,
a system is divided into relatively course computational units,
each with a single label dictating its security policy.
Only
communication between isolated computational units must be tracked.
A recent system named SWAPI adds IFC to the
browser by identifying \emph{Web workers} as an existing computational
unit~\cite{swapi}.  Communication between workers is mediated using
IFC to ensure non-interference, preventing sensitive workers from
influencing the computation of less sensitive workers.
This coarse-grained approach provides a number of advantages:
(1) reduced runtime overhead because checks need only
be performed at isolation boundaries, (2) minimal changes to an
existing programming language when adding IFC, which (3) allows
the reuse of existing programs.  Finally, (4) associating
a single security label with the entire computational unit simplifies
understanding and easy reasoning about the correctness of the
system, without information-flow reasoning about the
technical details of the semantics of the programming language.

A further benefit of the coarse-grained approach
is that a single IFC design and semantics can be generalized
to a large class of programming languages.
Leveraging this insight, we define a general form of coarse-grained
dynamic IFC and show how IFC can be combined with \emph{any} programming
language conforming to a general semantic framework.
At the core of our IFC system is a sandboxing construct that isolates
potentially sensitive computations, allowing them to
communicate only through clearly specified interfaces.
Based on a framework for combining the operational semantics
of our core IFC calculus with the operational semantics of any target language,
we formally state and prove non-interference guarantees that are
independent of the choice of specific target language.

One challenge in the design of our system is that the semantics for the
retrofitted IFC language may not accurately correspond to the optimized
implementation details of a particular target language.
We discuss and partially address this issue
by characterizing isomorphisms between the operational semantics of our
defined language and a concrete implementation, showing that if this
relationship holds, then noninterference in the abstract specification
carries over to the concrete specification.

Our contributions can be summarized as follows:
\begin{itemize}
  \item We give formal semantics for a core coarse-grained
  information flow control language.
  We then show how a large class of target languages can be combined
  with this IFC language and prove that the result provides
  non-interference. (Section~\ref{sec:retrofit})
%  \item We show how to extend the Matthews-Findler method from just
%  languages that are not simply expressions evaluating to values,
%  but may be collections of threads executing nondeterministically.
  \item We provide a proof technique to show the non-interference
  of a concrete semantics for a potentially optimized IFC language
  by means of an isomorphism, and show a class of restrictions on
  the IFC language that preserves non-interference. (Section~\ref{sec:formal})
  \item We connect our formal semantics to real implementations of
  coarse-grained IFC systems for Javascript and Haskell, and explain
  how our system could be used to enforce IFC in C. (Section~\ref{sec:real})
  \item We briefly describe ways to enrich the core IFC language with
  more advanced concepts such as labeled values, privileges, or a
  notation of clearance. (Section~\ref{sec:extensions})
  \item We informally relate our results to a monadic interpretation
      of IFC which guided our design. (Section~\ref{sec:monad})     
\end{itemize}

\cut{

(Something about the importance of IFC).

One barrier to the adoption of information flow control has been the
fact that it often incurs a large performance cost.  This usually stems
from the fact that most existing programming languages do not have
facilities for enforcing isolation.  Thus information flow control
checks must be applied at a very fine-grained level, e.g.\ all values in
the system must be labeled, resulting in large overhead for ordinary
operations.

Motivated by these problems, there has been increasing interest in
coarse-grained IFC systems, which trade-off precision for reduced
overhead.  These systems are characterized by floating label associated
with a thread of execution, so that access to labeled data taints the
entire thread, solving the problem of flow-sensitivity.  Typically,
these systems require strong isolation between threads, which previously
has been enforced by the type system. (LIO)  This has made this method
difficult to apply to languages which are unable to statically enforce
such strong isolation.

In this paper, we describe a simple but general methodology for using
isolation of \emph{execution contexts}, e.g.\ an instance of the
JavaScript engine, in order to add information-flow control to an
existing language.  This is a very practical approach, as there are many
languages which have built-in capabilities for strong isolation by
forking an execution context (i.e. Web Workers).  To validate this
methodology, we describe its application to Haskell (LIO), to JavaScript
(Browbound), to C (HipStar) and to Java (Aeolis).  The essential idea is
to combine the formal models of the source language and a minimal IFC
language, using the embedding technique described in Matthews and
Findler '07.

Our contributions are as follows:

\begin{itemize}
    \item We define a minimal IFC language which describes the essence
        of coarse-grained information flow control.

    \item We describe how to combine this IFC language with an existing
        source language in the style of Matthews-Findler, with a twist:
        there are arbitrarily many copies of the source language, which
        do not share execution contexts.  Mediating between these languages
        requires serialization of some sort (we make this notion precise
        in our paper), making our combined system a distributed one.

    \item We carry out this methodology on four existing languages, and
        show its adequacy with respect to systems that were specialized
        for these languages.  In particular, our definitions are general
        enough to enable relaxed isolation when the source language is
        able to give stronger static guarantees.

    \item We show how to extend the Matthews-Findler method from just
        languages that are not simply expressions evaluating to values,
        but may be collections of threads executing nondeterministically.
\end{itemize}

The organization of the paper is as follows: first, we describe how to
add information flow control to JavaScript, showing the general outline of
our procedure. Next, we describe the procedure in generality.  Finally, we
apply the procedure to a number of systems.
}
