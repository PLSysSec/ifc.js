\section{Introduction}
\label{sec:intro}
\cut{

(Something about the importance of IFC).

One barrier to the adoption of information flow control has been the
fact that it often incurs a large performance cost.  This usually stems
from the fact that most existing programming languages do not have
facilities for enforcing isolation.  Thus information flow control
checks must be applied at a very fine-grained level, e.g.\ all values in
the system must be labeled, resulting in large overhead for ordinary
operations.

Motivated by these problems, there has been increasing interest in
coarse-grained IFC systems, which trade-off precision for reduced
overhead.  These systems are characterized by floating label associated
with a thread of execution, so that access to labeled data taints the
entire thread, solving the problem of flow-sensitivity.  Typically,
these systems require strong isolation between threads, which previously
has been enforced by the type system. (LIO)  This has made this method
difficult to apply to languages which are unable to statically enforce
such strong isolation.

In this paper, we describe a simple but general methodology for using
isolation of \emph{execution contexts}, e.g.\ an instance of the
JavaScript engine, in order to add information-flow control to an
existing language.  This is a very practical approach, as there are many
languages which have built-in capabilities for strong isolation by
forking an execution context (i.e. Web Workers).  To validate this
methodology, we describe its application to Haskell (LIO), to JavaScript
(Browbound), to C (HipStar) and to Java (Aeolis).  The essential idea is
to combine the formal models of the source language and a minimal IFC
language, using the embedding technique described in Matthews and
Findler '07.

Our contributions are as follows:

\begin{itemize}
    \item We define a minimal IFC language which describes the essence
        of coarse-grained information flow control.

    \item We describe how to combine this IFC language with an existing
        source language in the style of Matthews-Findler, with a twist:
        there are arbitrarily many copies of the source language, which
        do not share execution contexts.  Mediating between these languages
        requires serialization of some sort (we make this notion precise
        in our paper), making our combined system a distributed one.

    \item We carry out this methodology on four existing languages, and
        show its adequacy with respect to systems that were specialized
        for these languages.  In particular, our definitions are general
        enough to enable relaxed isolation when the source language is
        able to give stronger static guarantees.

    \item We show how to extend the Matthews-Findler method from just
        languages that are not simply expressions evaluating to values,
        but may be collections of threads executing nondeterministically.
\end{itemize}

The organization of the paper is as follows: first, we describe how to
add information flow control to JavaScript, showing the general outline of
our procedure. Next, we describe the procedure in generality.  Finally, we
apply the procedure to a number of systems.
}
