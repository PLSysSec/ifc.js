\section{Introduction}
\label{sec:intro}

A defining aspect of web platforms is the combinability of many
components of various providence.  This pattern shows up in browser
extensions, which run JavaScript code alongside third-party website
code, web applications, which include possibly untrusted third-party
libraries, and mash-up websites, which combine code and data from
websites which may not even be aware of each other's existence.  While
this combinability has offered great flexibility, it also poses a set of
unique security challenges: in particular, maintaining the privacy of
data in these settings is difficult, if not impossible.

Information flow control (IFC) is a promising technique for addressing these
problems, by tracking the flow of sensitive data through a system and
confining untrusted code so that it cannot exfiltrate data, except as
per a information flow policy.  Significant research has been devoted to
adding various forms of IFC to different kinds of programming languages
and systems.  In the context of the web, however, there is a strong
motivation to preserve the language JavaScript, and retrofit information
flow control on top of it.  A key challenge in the design of these
systems is ensuring they can be implemented efficiently: when the
semantics specify that information flow must be tracked at a
fine-grained level, e.g., per value in the system,  it can lead to
impractical runtime overheads even for ordinary operations.

An alternative to this is a more \textit{coarse-grained} approach
to IFC by trading off precision for efficiency.  Here, computational
units are associated with a floating label which protects all data
in this unit.
A recent example dubbed SWAPI adds IFC to the web by extending
Javascript with coarse-grained IFC by identifying web workers as
an existing computational unit.  Communication between workers can
efficiently be mediated in an IFC aware way to ensure a notation
non-interference, where sensitive workers cannot influence the
computations in less sensitive workers.

This coarse-grained approach as employed by SWAPI provides a number
of advantages; (1) reduced runtime overhead because checks need only
be performed at isolation boundaries, (2) minimal changes to an
existing programming language when adding IFC, which (3) allows
the reuse of existing programs.  Finally, (4) the simplicity
of a single security label per computational unit facilitates
understanding and easy reasoning about the correctness of the
system, in particular without having to reason about all the
technical details of the semantics of the programming language
at hand.

The recognition of the simplicity of this coarse-grained approach
to IFC allows us to generalize it to a large class of programming
languages.  In this paper we identify the key concepts of coarse-grained
dynamic IFC and show how these can be combined with a programming
language, which we will call the target language.  We achieve this
by using an embedding that combines the operational semantics
of the core IFC calculus and the target language.
At the core of our IFC system we use a sandboxing operation that allows
the execution of potentially sensitive computations in isolation,
while communicating through clearly specified interfaces with other
sandboxed operations.
We formally state and prove the non-interference guarantees that our
system gives, independently of the choice of the target language.

One challenge in the design of such a general IFC calculus that
is supposed to work for a large class of programming languages is
that the stated semantics might not correspond well to the
semantics of a concrete implementation for a particular choice
of target language.  We address this issue by using the notation
of isomorphism to characterize a condition that guarantees
non-interference of the concrete system without having to prove
this property manually.

Our key contributions can be summarized as follows:
\begin{itemize}
  \item We give formal semantics for a core IFC language that
  captures the essence of coarse-grained information flow control.
  \item We show how a large class of target languages can be combined
  with this IFC language and prove that the resulting system provides
  non-interference.
%  \item We show how to extend the Matthews-Findler method from just
%  languages that are not simply expressions evaluating to values,
%  but may be collections of threads executing nondeterministically.
  \item We provide a proof technique to show the non-interference
  of a concrete semantics for a potentially optimized IFC language
  by means of an isomorphism, and show a class of restrictions on
  the IFC calculus that preserves non-interference.
  \item We sketch how the core IFC language can be enriched with
  more advanced concepts such as labeled values, privileges or a
  notation of clearance.
  \item We connect our formal semantics to real implementations of
  coarse-grained IFC systems for Javascript and Haskell, and explain
  how our system could be used to enforce IFC in C.
  \item We informally connect our results to a monadic interpretation
  of IFC which guided our design.
\end{itemize}


\cut{

(Something about the importance of IFC).

One barrier to the adoption of information flow control has been the
fact that it often incurs a large performance cost.  This usually stems
from the fact that most existing programming languages do not have
facilities for enforcing isolation.  Thus information flow control
checks must be applied at a very fine-grained level, e.g.\ all values in
the system must be labeled, resulting in large overhead for ordinary
operations.

Motivated by these problems, there has been increasing interest in
coarse-grained IFC systems, which trade-off precision for reduced
overhead.  These systems are characterized by floating label associated
with a thread of execution, so that access to labeled data taints the
entire thread, solving the problem of flow-sensitivity.  Typically,
these systems require strong isolation between threads, which previously
has been enforced by the type system. (LIO)  This has made this method
difficult to apply to languages which are unable to statically enforce
such strong isolation.

In this paper, we describe a simple but general methodology for using
isolation of \emph{execution contexts}, e.g.\ an instance of the
JavaScript engine, in order to add information-flow control to an
existing language.  This is a very practical approach, as there are many
languages which have built-in capabilities for strong isolation by
forking an execution context (i.e. Web Workers).  To validate this
methodology, we describe its application to Haskell (LIO), to JavaScript
(Browbound), to C (HipStar) and to Java (Aeolis).  The essential idea is
to combine the formal models of the source language and a minimal IFC
language, using the embedding technique described in Matthews and
Findler '07.

Our contributions are as follows:

\begin{itemize}
    \item We define a minimal IFC language which describes the essence
        of coarse-grained information flow control.

    \item We describe how to combine this IFC language with an existing
        source language in the style of Matthews-Findler, with a twist:
        there are arbitrarily many copies of the source language, which
        do not share execution contexts.  Mediating between these languages
        requires serialization of some sort (we make this notion precise
        in our paper), making our combined system a distributed one.

    \item We carry out this methodology on four existing languages, and
        show its adequacy with respect to systems that were specialized
        for these languages.  In particular, our definitions are general
        enough to enable relaxed isolation when the source language is
        able to give stronger static guarantees.

    \item We show how to extend the Matthews-Findler method from just
        languages that are not simply expressions evaluating to values,
        but may be collections of threads executing nondeterministically.
\end{itemize}

The organization of the paper is as follows: first, we describe how to
add information flow control to JavaScript, showing the general outline of
our procedure. Next, we describe the procedure in generality.  Finally, we
apply the procedure to a number of systems.
}
