\section{Introduction}
\label{sec:intro}
%   \Red{DM had some very good comments on how to make this sound less
%     like a pitch for LIO. Outline for something more compelling (not
%     necessarily in this order):
%   \begin{itemize}
%     \item Motivate IFC
%     \item Coarse grained IFC is easy
%     \item Coarse grained IFC is sufficient (vs. fine grained); do by citation
%     \item We have the right API and it's language-agnostic; proof is also language independent
%     \item You can ``drop it in''
%   \end{itemize}
%   }

Modern web content is rendered using a potentially large number of
different components with differing provenance.
Disparate and untrusting components may arise from browser
extensions (whose JavaScript code runs alongside website
code), web applications (with possibly untrusted third-party
libraries), and mashups (which combine code and data from
websites that may not even be aware of each other's existence.)
%While just-in-time combination of untrusting components
%offers great flexibility, it also poses complex security challenges.
%In particular,
Maintaining data privacy in the face of malicious
extensions, libraries, and mashup components has been rather difficult.
%and in general effectively impossible.

Information flow control (IFC) is a promising technique that provides security
by tracking the flow of sensitive data through a system.  Untrusted code is
confined so that it cannot exfiltrate data, except as per an information flow
policy.  Significant research has been devoted to adding various forms of IFC to
different kinds of programming languages and systems.  In the context of the
web, however, there is a strong motivation to preserve JavaScript's semantics
and avoid any modification to its engine.
%, while retrofitting it with dynamic
%information flow control.

%%% Ale: Related work?
%% One approach to information flow control is fine-grained tracking,
%% which offers great flexibility.
%% However, these systems
%% require deep integration with the programming language and modify
%% the semantics in non-trivial ways.  This makes fine-grained systems
%% less suitable in contexts where preserving an existing language
%% is important.
%
%% Moreover, the task of adding fine-grained IFC even to a simple language is
%% non-trivial~\cite{hritcu2013testing}; when considering a real-world language,
%% such as JavaScript, this challenge becomes almost insurmountable.

Inspired by OS research~\cite{Zeldovich:2006}, we present a
\textit{coarse-grained} dynamic IFC monitor to JavaScript (as specified by
ECMAScript~\cite{ecma}). Specifically, JavaScript code is divided into relatively
coarse computational units (i.e. workers), each with a single label dictating
its security policy. As a result, it is just enough to track communication
between isolated computational units.
%A recent system named COWL~\cite{swapi} adds IFC to the
%browser by identifying \emph{web workers} as an existing computational
%unit.  Communication between workers is mediated using
%IFC to ensure non-interference, preventing sensitive workers from
%influencing the computation of less sensitive workers.
This technique provides a number of advantages: (1) no changes to JavaScript's
semantics when adding IFC ---our approach only exposes an small API to
JavaScript code in order to interact with the monitor---, and
% which (2) allows
%the reuse of existing programs.  Furthermore,
(2) reduced runtime overhead because checks only need to be performed at isolation
boundaries instead of at every instruction in the code~\cite{JSFlow}.
%, compared to fine-grained systems were the runtime overhead can be
% impractical~\cite{JSFlow}.
Finally, (3) associating a single security label with the entire computational
unit simplifies understanding and reasoning about the correctness of the system,
without reasoning about most of the semantics details of JavaScript.
% underlying programming language, i.e., JavaScript.

To reason about our monitor, we introduce a \emph{generic} formalism which
translates coarse-grained IFC ideas~\cite{Zeldovich:2006} into a language-based
setting: an information flow control system should be thought of as multiple
instances of \emph{completely isolated language runtimes} or \emph{tasks}, with
information flow control applied to inter-task communication.
% We describe a
% formal framework in which an IFC system can be designed once and then applied to
% any programming language which has control over external effects like
% JavaScript.
%(e.g., JavaScript) or C with access to hardware privilege separation).
We formalize our framework by using the Matthews-Findler's
approach~\cite{Matthews:2007:OSM:1190216.1190220} for combining operational
semantics and prove non-interference guarantees that are independent of the
choice of the specific underlying programming language. %, e.g., JavaScript.
%framework to , being one instead of
%that ECMAScript. %target language.

%% There are a number of points that distinguish this setting from
%% previous coarse-grained IFC systems.
%% %
%% First, even though the underlying semantic model involves communicating
%% tasks, these tasks can be coordinated together in ways that simulate
%% features of traditional languages.
%% %
%% In fact, simulating
%% features in this way is a useful \emph{design tool} for discovering
%% what variants of the features are permissible and which are not.
%% %
%% Second, although completely separate tasks are semantically easy to
%% reason about, real-world implementations often blur the lines between
%% tasks in the name of efficiency.
%% Characterizing what optimizations are permissible is subtle, since
%% removing transitions from the operational semantics of a language can
%% break non-interference.  We partially address this issue
%% by characterizing isomorphisms between the operational semantics of our
%% abstract language and a concrete implementation, showing that if this
%% relationship holds, then non-interference in the abstract specification
%% carries over to the concrete implementation.


Our contributions can be summarized as follows:
\begin{itemize}
  \item We give formal semantics for a generic coarse-grained dynamic
    information flow control monitor which is agnostic to non-IFC constructs.
    %We show how a
  \item We show non-interefence results when target languages exhibit a notion
    of isolated computations and control of external side-effects.
    %large class of target languages can be combined with this IFC language and
    %prove that the result provides
    %non-interference. (Sections~\ref{sec:retrofit} and \ref{sec:formal})
  %% \item We provide a proof technique to show the non-interference
  %% of a concrete semantics for a potentially optimized IFC language
  %% by means of an isomorphism and show a class of restrictions on
  %% the IFC language that preserves non-interference. (Sections~\ref{sec:concrete})
  \item
  %We have implemented an IFC system based on these semantics
  %or Node.js, and
  We connect our formalism to COWL~\cite{swapi}, a
  client-side IFC monitor for JavaScript in Firefox.
  %Furthermore, we outline an implementation for the C programming
  %language.
  %(Section~\ref{sec:real})
%  \item We show how to extend the Matthews-Findler method from just
%  languages that are not simply expressions evaluating to values,
%  but may be collections of threads executing nondeterministically.
  \item We describe ways to enrich the core IFC language with
  more advanced concepts such as labeled values, labeled references, or a
  notion of clearance. %(Section~\ref{sec:extensions})
\end{itemize}

\cut{

(Something about the importance of IFC).

One barrier to the adoption of information flow control has been the
fact that it often incurs a large performance cost.  This usually stems
from the fact that most existing programming languages do not have
facilities for enforcing isolation.  Thus information flow control
checks must be applied at a very fine-grained level, e.g.\ all values in
the system must be labeled, resulting in large overhead for ordinary
operations.

Motivated by these problems, there has been increasing interest in
coarse-grained IFC systems, which trade-off precision for reduced
overhead.  These systems are characterized by floating label associated
with a thread of execution, so that access to labeled data taints the
entire thread, solving the problem of flow-sensitivity.  Typically,
these systems require strong isolation between threads, which previously
has been enforced by the type system. (LIO)  This has made this method
difficult to apply to languages which are unable to statically enforce
such strong isolation.

In this paper, we describe a simple but general methodology for using
isolation of \emph{execution contexts}, e.g.\ an instance of the
JavaScript engine, in order to add information-flow control to an
existing language.  This is a very practical approach, as there are many
languages which have built-in capabilities for strong isolation by
forking an execution context (i.e. Web Workers).  To validate this
methodology, we describe its application to Haskell (LIO), to JavaScript
(Browbound), to C (HipStar) and to Java (Aeolis).  The essential idea is
to combine the formal models of the source language and a minimal IFC
language, using the embedding technique described in Matthews and
Findler '07.

Our contributions are as follows:

\begin{itemize}
    \item We define a minimal IFC language which describes the essence
        of coarse-grained information flow control.

    \item We describe how to combine this IFC language with an existing
        source language in the style of Matthews-Findler, with a twist:
        there are arbitrarily many copies of the source language, which
        do not share execution contexts.  Mediating between these languages
        requires serialization of some sort (we make this notion precise
        in our paper), making our combined system a distributed one.

    \item We carry out this methodology on four existing languages, and
        show its adequacy with respect to systems that were specialized
        for these languages.  In particular, our definitions are general
        enough to enable relaxed isolation when the source language is
        able to give stronger static guarantees.

    \item We show how to extend the Matthews-Findler method from just
        languages that are not simply expressions evaluating to values,
        but may be collections of threads executing nondeterministically.
\end{itemize}

The organization of the paper is as follows: first, we describe how to
add information flow control to JavaScript, showing the general outline of
our procedure. Next, we describe the procedure in generality.  Finally, we
apply the procedure to a number of systems.
}
