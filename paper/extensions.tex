\section{Extensions and Limitations}
\label{sec:extensions}

In this section we consider several extensions to our IFC system.
%
Specifically, we discuss how the specification language can be
extended to consider other IFC-aware features (e.g., fine-grained
labeled values), a static type system, or more complex scheduling
policies.
%
When considering these extensions we also highlight some limitations
of our approach.

\subsection{IFC-aware language features}
\label{sec:extensions:labeled}

\subsubsection{Labeled objects}

\paragraph{Labeled values}
\paragraph{Labeled references}
\paragraph{Labeled synchronization primitives}
\subsubsection{Privileges}
\subsubsection{Clearance}

\subsection{Type safety}
\label{sec:extensions:types}

One important consideration for any new language feature is whether
or not it preserves type safety.  If implementations are allowed to
have undefined behavior when the system gets stuck, concerns of type
safety can be directly applicable to security.

In our presentation, we have demanded that implementations \emph{not}
have undefined behavior when getting stuck: in such situations, the
\textsc{I-noStep} rule applies, where the stuck thread should be dropped
from execution.  Our combined language will be not get stuck, even if
the target language could get stuck.  This sort of guarantee can be
achieved at a coarse granularity for languages like C by using hard
isolation.  However, for many other languages, this is too stringent a
requirement.

A possible way to relax this requirement is to drop the \textsc{I-noStep}
rule, and instead demand type-safety of the combined language.  This
depends on the type system of the target language, so it is difficult to
make any general statements about how one would go about doing this.  However,
there are few general remarks to be made:

\begin{itemize}
    \item In Matthews and Findlers original
        paper~\cite{Matthews:2007:OSM:1190216.1190220}, an emphasis was
        on using type boundaries to mediate between the type systems of
        the two languages, i.e. handling conversions of values from
        one language to the other.  These techniques are directly applicable here.

    \item In the case of mini-ML, type safety proceeds by a preservation theorem
        that refers to well-typed stores.  In our setting, there are now multiple
        stores, and expressions may move from being interpreted with one store
        to another (e.g. when an address is sent from one thread to
        another); a clear violation of type safety.  In this case, operations
        such as \textbf{send} have their typing rules require
        the expressions being sent be typeable in an arbitrary well-typed store,
        statically disallowing the sending of addresses, or any types which
        may contain addresses.  In practice, this may be further restricted to
        types which can be easily marshalled, e.g. strings.

    \item Similarly, the choice of $\kappa$ (from Section~\ref{sec:retrofit}) directly
        influences the difficulty of the type-safety proof for
        \textbf{fork} when the target language has a store.  When
        $\kappa$ is identity, most expressions can be allowed, since the store
        remains the same; if $\kappa$ drops the store, however, only closed expressions
        can be forked.
\end{itemize}

\subsection{Safe scheduling policies}
Our specification language is parametrized by a scheduling policy
|alpha|, which maps a task list to a potentially different task list.
%
As previously discussed, the precise definition of |alpha|
dictates whether the language is TSNI, TINI, or neither.
%
For simplicity we considered two popular policies |roundrobinf| and
|seqf| for which we showed TSNI and TINI, respectively.
%
However, our definitions allow for other scheduling policies that only
rely on the current task list.
%
For example, this allows us to implement the scheduler of~\tocite{}
that always schedules less sensitive threads first; this can be
employed to address external timing covert channels where an attacker
can measure the delay between output events.\footnote{
  When considering a label lattice that is not totally ordered, e.g.,
  DCLabels~\tocite{}, this scheduling policy is considerably more
  complex. See~\tocite{}.
}
%
More generally, we believe that deterministic schedulers that always
make ``low-progress,'' i.e., if a task whose label is not above the
current task's label will will eventually run, and do not decide which
low tasks to schedule according to data more sensitive than the tasks'
label, i.e., the scheduler does not schedule one public thread over
another according to sensitive data, to be safe.
%
We leave the proof of this claim to future work.
%

Despite allowing a number of practical schedulers to be expressed, our
scheduler parametrization is limited.
%
For instance, since |alpha| is a map on task lists, schedulers that
rely on the global state |iS| or previous task configurations cannot
be expressed.
%
Though, we do not believe this to be a fundamental limitation, our
current formalization cannot directly be applied to more-powerful, but
safe, scheduling policies, as considered in~\tocite{}.
%
More fundamentally, our definitions rely on deterministic relations,
and thus extending the system to consider non-deterministic schedulers
is non-trivial.
%
For instance, this may potentially require the security condition to
consider \emph{low-determinism}, which states that a program is secure
only if |l|-equivalent results are deterministic~\tocite{}. %both andrei and steve's papers


\subsection{Other target languages}

\subsubsection{External effects}
\label{sec:extensions:external}
Application specific, use XHR as driving example.
General way to think of safety is internalize and treat as a labeled
object; or message to thread that has access to unsafe API, but
exposes labeled safe messaging API.



\cut{

The good thing about our approach is that we are indifferent to the
functionality implemented in the IFC language: as long as you can
prove termination sensitive non-interference with the IFC language
\Red{What is the IFC language? Make sure it is written down}, you
can combine it with another target language.  In this section,
we briefly review various extensions you can make to the base IFC
language to provide IFC-aware versions of target language features.


}
\begin{itemize}
\item Label transition systems.
\item Non-deterministic reduction.
\end{itemize}

