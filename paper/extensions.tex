\section{Extensions and Limitations}
\label{sec:extensions}

In this section we consider several extensions to our IFC system.
%
Specifically, we discuss how the specification language can be
extended to consider other IFC-aware features (e.g., fine-grained
labeled values), a static type system, or more complex scheduling
policies.
%
When considering these extensions we also discuss some limitations
of our approach.

\subsection{IFC language features}
\label{sec:extensions:labeled}

Different concrete IFC implementations may wish to extend our minimal
system with labeled constructs appropriate for their envisioned
applications.
%
For example, SWAPI provides a labeled version of the XHR object, while
LIO implements a labeled file system, use in server-side web
applications~\cite{hails}.
%
Below we
consider the addition of several labeled constructs to the abstract specification.
%
We remark that that the non-interference proofs must account for the
new constructs, since they amend the IFC calculus semantics (usually
by addition).

\paragraph{Labeled values}
%{
%format Lb = "\textbf{Labeled}"
%format label = "\textbf{label}"
In traditional language-based dynamic IFC systems, a label is
associated with values.
%
Hence, a program that, for example, simply writes labeled messages to
a labeled log can operate on both public and sensitive values.
%
In its simplest form, our coarse grained system requires that the
current label of a task be at least at the level of the sensitive data
to reflect the fact that such data is in scope.
 
Thus, an extension that allows supports such fine-grained explicitly
labeled values is essential.
%
To this end, we extend the IFC calculus with explicitly labeled
values, much like those of LIO and
Breeze~\cite{lio, Hritcu:2013:YIB:2497621.2498098}: |tv ::= cdots
inlinesep Lb il tv|.
%
Following LIO, we say that the value |tv| is protected by label |il|,
while the label |il| itself is protected by the task's current label.
%
%
Directly, the label of such values can be inspected the task without
requiring the current label to be raised.
%
However, when a task wishes to inspect the protected value |tv|, it
must first raise it label to at least |il| to reflect that it is
incorporating data at such sensitivity level in its scope.
%
When creating labeled values the label |il| must be above
the current label; otherwise it cannot be said that protection has
been transferred from the current label to |il|.
%
(For these rules, we assume that the |Lb| constructor is not part of
the surface syntax and thus cannot be accessed directly to construct
or destruct such values without label checks.)
% 
We omit the reduction rules for labeled values since they closely
follow those presented in~\cite{lio}.
%}

\paragraph{Labeled mutable references/variables/channels}
%
Extending the calculus with other labeled features, such as
references, mutable variables (MVars)~\cite{CH96}, or channels,
follows in a similar way.
%
In these cases, however, we must keep track of the additional state
(as opposed to the labeled value case which requires no additional
bookkeeping).
%
While we can modify the IFC calculus to add such labeled state to each
individual task, adding it to the system state |iS| leads to more
interesting use cases.
%
Specifically, by amending |iS|, as in~\cite{lio,
stefan:addressing-covert}, we can allow threads to use these
constructs to synchronize, or communicate with constructs other than
|send|/|recv| in a safe manner.
%
For example, when extending the calculus with labeled references, |iS|
additionally contains a store that maps addresses to |(il, tv)| pairs
which can be read and written to by different tasks through a labeled
|ref| implementations.
%
Since such labeled constructs have also been considered before in other
concurrent systems, we do not discuss them further.

\paragraph{Privileges}
Decentralized IFC extends IFC with the decentralized label model of
Myers and Liskov~\cite{myers:dlm} to allow for more general
applications, including systems consisting of mutually distrustful
parties.  In a decentralized system, a computation is executed with a
set of \emph{privileges}, which, when exercised, allow the computation
to declassify data (e.g., by lowering the current label).
%
Practical IFC systems
(e.g.,~\cite{Zeldovich:2006, lio,
Hritcu:2013:YIB:2497621.2498098, myers:jif}) rely on privileges to
implement many applications.
%
Since both the LIO and SWAPI implementations already support such features,
we believe that extending our calculus to consider privileges is
straight forward.
%
However, the challenge with such an extension lies in the precise
security guarantees that must be proved.
%
Addressing this problem is a natural direction for this work.

\paragraph{Clearance}
%
LIO, SWAPI, and Breeze additionally provide a discretionary access
control mechanism---called \emph{clearance}---at the language
level~\cite{Hritcu:2013:YIB:2497621.2498098, lio}; this mechanisms is
used to restrict a computation from accessing data (or communicating
with entities) above a specified label, the clearance.
%
For simplicity, we omitted clearance from our formalism.
%
We only remark that the mechanism generalizes beyond these IFC systems
in a straight forward manner and does not affect our definitions or
proofs in any meaningful way.


\subsection{Type safety}
\label{sec:extensions:types}

One important consideration for any new language feature is whether
or not it preserves type safety.  If implementations are allowed to
have undefined behavior when the system gets stuck, concerns of type
safety can be directly applicable to security.

In our presentation, we have demanded that implementations \emph{not}
have undefined behavior when getting stuck: in such situations, the
\textsc{I-noStep} rule applies, where the stuck thread should be dropped
from execution.  Our combined language will be not get stuck, even if
the target language could get stuck.  This sort of guarantee can be
achieved at a coarse granularity for languages like C by using hard
isolation.  However, for many other languages, this is too stringent a
requirement.

A possible way to relax this requirement is to drop the \textsc{I-noStep}
rule, and instead demand type-safety of the combined language.  This
depends on the type system of the target language, so it is difficult to
make any general statements about how one would go about doing this.  However,
there are few general remarks to be made:

\begin{itemize}
    \item In Matthews and Findlers original
        paper~\cite{Matthews:2007:OSM:1190216.1190220}, an emphasis was
        on using type boundaries to mediate between the type systems of
        the two languages, i.e. handling conversions of values from
        one language to the other.  These techniques are directly applicable here.

    \item In the case of mini-ML, type safety proceeds by a preservation theorem
        that refers to well-typed stores.  In our setting, there are now multiple
        stores, and expressions may move from being interpreted with one store
        to another (e.g. when an address is sent from one thread to
        another); a clear violation of type safety.  In this case, operations
        such as \textbf{send} have their typing rules require
        the expressions being sent be typeable in an arbitrary well-typed store,
        statically disallowing the sending of addresses, or any types which
        may contain addresses.  In practice, this may be further restricted to
        types which can be easily marshalled, e.g. strings.

    \item Similarly, the choice of $\kappa$ (from Section~\ref{sec:retrofit}) directly
        influences the difficulty of the type-safety proof for
        \textbf{fork} when the target language has a store.  When
        $\kappa$ is identity, most expressions can be allowed, since the store
        remains the same; if $\kappa$ drops the store, however, only closed expressions
        can be forked.
\end{itemize}

\subsection{Scheduling policies}
Our specification language is parametrized by a scheduling policy
|alpha|, which maps a task list to a potentially different task list.
%
As previously discussed, the precise definition of |alpha|
dictates whether the language is TSNI, TINI, or neither.
%
For simplicity we considered two popular policies |roundrobinf| and
|seqf| for which we showed TSNI and TINI, respectively.
%
However, our definitions allow for other scheduling policies that only
rely on the current task list.
%
For example, this allows us to implement the scheduler of~\cite{Kashyap:2011}
that always schedules less sensitive threads first; this can be
employed to address external timing covert channels where an attacker
can measure the delay between output events.\footnote{
  When considering a label lattice that is not totally ordered, e.g.,
  DCLabels~\cite{myers:dlm,dclabels}, this scheduling policy is
  considerably more complex. See~\cite{Kashyap:2011}.
}
%
More generally, we believe that deterministic schedulers that always
make ``low-progress,'' i.e., if a task whose label is not above the
current task's label will will eventually run, and do not decide which
low tasks to schedule according to data more sensitive than the tasks'
label, i.e., the scheduler does not schedule one public thread over
another according to sensitive data, to be safe.
%
We leave the proof of this claim to future work.
%

Despite allowing a number of practical schedulers to be expressed, our
scheduler parametrization is limited.
%
For instance, since |alpha| is a map on task lists, schedulers that
rely on the global state |iS| or previous task configurations cannot
be expressed.
%
Though, we do not believe this to be a fundamental limitation, our
current formalization cannot directly be applied to more-powerful, but
safe, scheduling policies, as considered by~\cite{russo2006securing}.
%
More fundamentally, our definitions rely on deterministic relations,
and thus extending the system to consider non-deterministic schedulers
(or even non-deterministic target languages) is non-trivial.
%
For instance, this may potentially require the security condition to
consider \emph{low-determinism}, which states that a program is secure
only if |l|-equivalent results are deterministic~\cite{Zdancewic:Myers:CSFW03,
sabelfeld2003language}.

\subsection{External effects}
\label{sec:extensions:external}
Our embedding assumes that the target language not have any
primitives that can external-world effects.
%
Indeed, as discussed in Section~\ref{sec:real}, part of the challenge
when considering real languages is precisely imposing this restriction
on the concrete implementation.
%
Yet, external effects are crucial when implementing more complex
real-world applications.
%
For example, code in our modified IFC browser must load resources or
perform XHR to be useful.

Like labeled references, features with external effects must be
modeled in the IFC language; we must reason about the precise security
implications of features that otherwise inherently leak data.
%
Previous approaches have modeled external effects by internalizing the
effects as writes/reads to labeled channels/references~\tocite{}.
%
An alternative approach is to model such effects as messages to/from
certain labeled tasks.
%
These ``special'' tasks are trusted with access to the unlabeled
primitives that can be used to perform the external effects; since the
interface to these tasks is already part of the IFC language, the
proof only requires showing that this task does not leak information.
%
This latter approach of wrapping unsafe primitives is, for example,
used in SWAPI to allow for controlled network communication.
%
By wrapping the default XHR object, for example, we can allow code
to communicate with hosts according to the task's current label.
