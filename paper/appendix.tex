\appendix


\section{Formal Extensions}
\label{sec:appendix-extensions}

Here we formally define the syntax and semantics of the extensions
sketched in Section~\ref{sec:extensions}.
In Figure~\ref{fig:labeled-vals} we show how labeled values can be added,
while Figure~\ref{fig:labeled-refs} details labeled references formally.
For labeled values, we assume that the constructor |Labeled| is not part
of the surface syntax, but rather an internal construct.  Similarly,
the construct |ial| is internal in the labeled reference implementation.
These changes to the semantics require us to update the erasure function
|erasef il|, whose full definition is shown in Figure~\ref{fig:erasure2}.
Note that the soundness proof in Appendix~\ref{sec:appendix}
is done for the fully extended language with labeled values and
labeled references.

We also give details for the clearance extension below.

\subsection{Clearance}

As we have outlined in Section~\ref{sec:clearance}, we first extend
tasks with an additional label |ilc|, which corresponds to the
clearance of that task, and provide two primitives to read and
write that value:
\[ |fullconfc id il ilc tS ie| \]

\begin{figure}
  %{
  %format .->  = "\overset{\alpha}{\hookrightarrow}"
  %format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
  \begin{code}
    ie  ::= cdots | getClearance | setClearance ie
    iE  ::= cdots | setClearance iE
  \end{code}
  \begin{mathpar}
      \inferrule[I-getClearance]
      { }
      {|
        niconf iS id il ilc getClearance
        ->
        niconf iS id il ilc ilc
        |}
      
      \and
      \inferrule[I-setClearance]
      { }
      {|
        niconf iS id il ilc (setClearance ilc')
        ->
        niconf iS id il ilc' unit
        |}
  \end{mathpar}
  \caption{Syntax and semantics for clearance.  These rules are
    understood to be an addition to the existing rules given earlier,
    except for the \textsc{I-sandbox} rule, which replaces the previous
    one.
    All existing rules do not modify the clearance.}
  \label{fig:clearance}
  %}
\end{figure}



\begin{figure}
  %{
  %format .->  = "\overset{\alpha}{\hookrightarrow}"
  %format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
  \begin{code}
    iv  ::= cdots | Labeled il ie
    ie  ::= cdots | label ie ie | unlabel ie | labelOf ie
    iE  ::= cdots | label iE ie | unlabel iE | labelOf iE
  \end{code}
  \begin{mathpar}
    \inferrule[I-label]
    {|
      il canFlowTo il'
    |}
    {|
      niconf iS id il (label il' ie)
      ->
      niconf iS id il (Labeled il' ie)
    |}
    \and
    \inferrule[I-unlabel]
    {}
    {|
      niconf iS id il (unlabel (Labeled il' ie))
      ->
      niconf iS id (il  lub il' ) ie
    |}
    \and
    \inferrule[I-labelOf]
    {|
    |}
    {|
      niconf iS id il (labelOf (Labeled il' ie))
      ->
      niconf iS id il (il')
    |}
  \end{mathpar}
  \caption{Syntax and semantics for labeled values.  These rules are
    understood to be an addition to the existing rules given earlier.}
  \label{fig:labeled-vals}
  %}
\end{figure}

\begin{figure}
  %{
  %format .->  = "\overset{\alpha}{\hookrightarrow}"
  %format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
  \begin{code}
    iv  ::= cdots | ial
    ie  ::= cdots | new ie ie | read ie | write ie ie
    iE  ::= cdots | new iE ie | new il iE | read E
                  | write iE ie | write ial iE
    iS  ::=  cdots | bracket iS (mapsto ial iv)
  \end{code}
  
  \begin{mathpar}
    \inferrule[I-new]
    {
      |il canFlowTo il'| \\
      |fresh ia|\\
      |iS'= bracket iS (mapsto (iall il') iv)|
    }
    {|
      niconf iS id il (new il' iv)
      ->
      niconf iS' id il (iall il')
      |}
    \and
    \inferrule[I-read]
    {}
    {|
      niconf iS id il (read ial')
      ->
      niconf iS id (il lub il') (readState iS (iall il'))
      |}
    \and
    \inferrule[I-write]
    {
      |il canFlowTo il'|\\
      |iS'= bracket iS (mapsto (iall il') iv)|
    }
    {|
      niconf iS id il (write ial' iv)
      ->
      niconf iS' id il (unit)
      |}
    \and
    \inferrule[I-labelOf2]
    {}
    {|
      niconf iS id il (labelOf ial')
      ->
      niconf iS id il (il')
      |}
  \end{mathpar}
  \caption{Syntax and semantics for labeled references.  These rules are
    understood to be an addition to the existing rules given earlier.}
  \label{fig:labeled-refs}
  %}
\end{figure}


\begin{figure}
  \begin{align*}
  &|erase il (iconf iS its) =
  iconf (erase il iS) (fltr (\ it . it = bullet) (map (erasef il) its))|\\
  &|fullconf id il' tS ie| \begin{cases}
  |bullet| & |il' cantFlowTo il| \\
  |fullconf id il' (erase il tS) (erase il ie)| & \text{otherwise}
  \end{cases} \\
  &|erase il (Labeled il' ie)|= \begin{cases}
  |Labeled il' bullet| & |il' cantFlowTo il| \\
  |Labeled il' ie| & \text{otherwise}
  \end{cases} \\
  &|erase il emptyset = emptyset|\\
  &|erase il (bracket iS (mapsto id Q)) =| \begin{cases}
  |erase il iS| & \text{|il' cantFlowTo il|, where |il'| is}\\
  & \text{the label of thread |id|} \\
  |bracket (erase il iS) (mapsto id (erase il Q))| & \text{otherwise}
  \end{cases} \\
  &|erase il (bracket iS (mapsto (iall il') iv)) =| \begin{cases}
  |bracket (erase il iS) (mapsto (iall il') bullet)| & \text{|il' cantFlowTo il|}\\
  |bracket (erase il iS) (mapsto (iall il') (erase il iv))| & \text{otherwise}
  \end{cases} \\
  &|erase il Q = filter il Q|
  \end{align*}
  \caption{Erasure function for the full IFC language, with all extensions.
    In all cases that are not specified, including target-language constructs,
    |erasef il| is applied homomorphically
    (e.g., |erase il (setLabel e) = setLabel (erase il e)|).
    This definition replaces the one from Figure~\ref{fig:erasure}, which
    is for the IFC language without extensions.}
  \label{fig:erasure2}
\end{figure}


\section{Full Non-Interference Proof}
\label{sec:appendix}

In the main body of the paper we have only sketched the proof structure
for Lemma~\ref{lemma:rr-tsni-general}.  Here we give it with full
details, and first state and proof another lemma that will be used in that
proof.

%\begin{lemma}
%  For any task lists |its|, |its'|, and tasks |it|, |it'| we have that
%  if
%  \begin{enumerate}
%    \item |iconf iS (it1, its) .-> iconf iS' (its')|
%    \item $|erase il it1|=|bullet|$
%  \end{enumerate}
%  then
%\end{lemma}

\begin{lemma}
  \label{lemma:high-not-blocking}
  For any task |it|, task lists |its|, store |iS|, and label |il|, if
  $|erase il it|=|bullet|$, then there exists a task list
  |its'| and a store |iS'| such that
  \begin{align}
  |iconf iS (it, its)| |.->| |iconf iS' (its, its')| \label{eq:hnb-1} \\
  |erase il its'|=|nil| \label{eq:hnb-2}\\
  |erase il iS'|=|erase il iS| \label{eq:hnb-3}
  \end{align}
\end{lemma}
\begin{proof}
  From $|erase il it|=|bullet|$ we know that the current label |lcurr| of |it|
  must be above |il|.  Furthermore, tasks can always take a step (if no
  regular rule applies, then \textsc{I-noStep} can be used), and thus
  we consider all rules that could be applied to execute |it|.
  \begin{description}
    \item[Case \textsc{I-noStep} and \textsc{I-done}]
    In this case, the task |it| is dropped,
    and thus |its'=nil| and |iS'=iS| satisfy
    conditions~\eqref{eq:hnb-2} and~\eqref{eq:hnb-3}.
    \item[Case \textsc{I-sandbox}]
    The newly created task has a label of at least |lcurr|, and will thus be
    erased, as required by condition~\eqref{eq:hnb-2}.  Furthermore, the
    state only changes for the newly created thread, and thus the state
    change is erased, showing~\eqref{eq:hnb-3}.
  \end{description}
  In all other rules, no new tasks are created, and thus |its'| consists of just
  the one task |it'|, to which |it| executed.  Since the tasks label can
  only increase, |it'| is still erased, showing condition~\eqref{eq:hnb-2}.
  We are left to show condition~\eqref{eq:hnb-3} for the remaining rules.
  \begin{description}
    \item[Case \textsc{I-send}]
    A new message triple with label |il'| gets added to the message
    queue of the receiving thread.  However, since |lcurr canFlowTo il'|,
    the triple will get erased.
    \item[Case \textsc{I-recv} and \textsc{I-noRecv}]
    In this case, only the queue of
    task |it| can change, which gets erased.
    \item[Case \textsc{I-new}] The newly allocated address has to be at a
    label at least as high as |lcurr|, and will thus be erased.
    \item[Case \textsc{I-write}] Only addresses with a label |il'| above
    |lcurr| can be written, thus the change in |iS1| will get erased.
    \item[Otherwise.]  None of the other rules modify the state |iS|, and
    thus |iS'=iS| will trivially satisfy condition~\eqref{eq:hnb-3}.
  \end{description}
\end{proof}

%\begin{lemma}
%  \label{lemma:erase-context}
%  For any expressions |ie1|, |ie2|, |ie1'|, context |iE1| as well as
%  label |il|, if
%  \[ |ie1= iHole2 iE1 ie1'| \quad \land \quad |erase il ie1 = erase il ie2| \]
%  then there exist |iE2|, |ie2'| such that
%  \[ |ie2= iHole2 iE2 ie2'| \quad \land \quad
%  |erase il ie1' = erase il ie2'|\neq|bullet| \]
%  Similarly, for any
%  expressions |ie1|, |ie2|, |te1'|, context |iE1| as well as
%  label |il|, if
%  \[ |ie1= tHole2 iE1 te1'| \quad \land \quad |erase il ie1 = erase il ie2| \]
%  then there exist |iE2|, |te2'| such that
%  \[ |ie2= tHole2 iE2 te2'| \quad \land \quad
%  |erase il te1' = erase il te2'|\neq|bullet| \]
%\end{lemma}
%\begin{proof}
%  TODO
%\end{proof}


\begin{proof}[Proof of Lemma~\ref{lemma:rr-tsni-general}]
  First, we observe there must be at least one task in |ic1|, otherwise
  it could not take a step.  Thus, |ic1| is of the form
  |iconf iS1 (it1, its1)|.
  Furthermore, let |ic2| be |iconf iS2 its2|.
  Consider two cases:
  \begin{itemize}
    \item $|erase il it1|=|bullet|$.
    By the definition of |erasef il|, we know that |il canFlowTo lcurr|
    where |lcurr| is the label of |it1|.
    In this case, we do not need to take a step for
    |ic2|, because |ic2'=ic2| will already be |il|-equivalent to |ic1'|.
    To show this, note that the tasks |its1| in |ic1| are left in the
    same order and unmodified (the scheduling policy only
    modifies the first task). The task |it1| either
    gets dropped (by \textsc{I-noStep}), or
    transforms into a task |it1'| as well as potentially spawning a new
    task |it1''|.  Since both |it1'| and |it1''| have a label that is
    at least as high as the label of |it1| (can be seen
    by inspecting all reduction rules), they will get filtered
    by |erasef il| in |ic1'|.  Therefore, the |il|-equivalence of the
    task list is guaranteed.
    Lets consider the possible changes to |iS1|:
    Only five reduction interact with |iS1|,
    thus it suffices to consider these cases:
    \begin{description}
      \item[Case \textsc{I-send}]
      A new message triple with label |il'| gets added to the message
      queue of the receiving thread.  However, since |lcurr canFlowTo il'|,
      the triple will get erased.
      \item[Case \textsc{I-recv} and \textsc{I-noRecv}]
      In this case, only the queue of
      task |it1| can change, which gets erased.
      \item[Case \textsc{I-new}] The newly allocated address has to be at a
      label at least as high as |lcurr|, and will thus be erased.
      \item[Case \textsc{I-write}] Only addresses with a label |il'| above
      |lcurr| can be written, thus the change in |iS1| will get erased.
    \end{description}
    This ensures that $|ic1'|\approx_{|il|}|ic2'|$, as well as
    $|ic2| |.->|^* |ic2'|$ (in zero steps), as claimed.
    %    \alphacondition{We need all scheduling policies to not change the order
    %      of any tasks (except for the first one).  Newly spawned task can appear
    %      anywhere in the list.}
    \item $|erase il it1|\neq|bullet|$.
    By the definition of |erasef il|, the task list |its2|
    in |ic2| must be of the
    form |its2', it2, its2''| (for some task lists |its2'|, |its2''| and
    some task |it2|)
    where
    \begin{align}
    |erase il its2'| = |nil| \\
    |erase il it2| = |erase il it1| \\
    |erase il its2''| = |erase il its1|
    \end{align}
    (where |nil| is the empty list of tasks).
    Now, intuitively we will first execute a number of steps to process
    the tasks in |its2'| (execute them one step and move them to the back
    of the task list, or drop them if they are done or stuck).  Then, the task
    |it2| can take the same step as |it1|, which will result in a configuration
    |ic2'|
    with the desired properties.
    More formally, we can proceed as follows:
    
    First, we can apply Lemma~\ref{lemma:high-not-blocking} continuously
    for all the task in |its2'|,
    until we reach a configuration |ic2''=iconf iS2' (it2, its2'', its2''')|
    for some |its2'''| such
    that |erase il its2''' = nil| and |erase il iS2| = |erase il iS2'|.
    We note that |erase il ic1 = erase il ic2''| (by the definition of
    |erasef il|).
    
    Now, the first task |it2| in |ic2''| is |il|-equivalent to the task |it1|.
    This implies that the two tasks must have the same id, label and
    can only differ in the expression or store if some subexpression
    is of the form |Labeled il' ie|.  In this case, the expression |ie| could
    be different in the two threads if |lcurr canFlowTo il'|.  However, none of the reduction rules
    depend on an expression in that position, and there is never a
    hole in that position
    where evaluation could take place.  Thus, the same rules will syntactically
    match for both task, and we are left to argue that all premises
    evaluate to the same values for |it1| and |it2|, as well as that
    the resulting states |iS1'| and
    |iS2''| are |il|-equivalent.
    The additional premises $P$ that follow
    the condition in Definition~\ref{def:restricted} are not a problem,
    since those
    predicates only depend on |erase il ic1|, which is equivalent
    to |erase il ic2''|, and thus those predicates evaluate in the same way.
    All other premises are either on the threads labels (which are the same),
    or on the state |iS1|, or |iS2'|, respectively.  Because
    |erase il iS1=erase il iS2'|, all of these also evaluate in the same way,
    as can be seen by simply considering all rules that involve or
    change the state:
    \begin{description}
      \item[Case \textsc{I-send}]
      Here, the task |it2| will send the same message to the same
      receiver queue. This
      queue is either completely erased, or it is |il|-equivalent.  In both
      cases, |il|-equivalence of |iS1'| and |iS2'| is preserved.
      \item[Case \textsc{I-recv} and \textsc{I-noRecv}]
      When the tasks are receiving a message, then by the reduction rules
      we know that they first filter the queue by the label
      |lcurr| of |it1|.  We
      also know that the queues are equivalent when filtered by the less
      restrictive label |il|, thus the messages received (or dropped) from the
      queue are equivalent.
      \item[Case \textsc{I-new}] The newly allocated address can be the same
      for both |it1| and |it2|, thus resulting in |il|-equivalent states.
      \item[Case \textsc{I-write}] By |erase il it1=earse il it2| both tasks
      write the same value, and therefore the resulting states will still
      be |il|-equivalent.
    \end{description}
    After |it2| has taken a step, we finally arrive in the desired
    configuration |ic2'=iconf iS2'' (its2'', its2''', its2'''')|, where
    |its2''''| contains the task resulting from executing |it2| (and
    might contain, zero (if the task was done or stuck), one (for most steps) or two tasks if a new task was launched).
    As required, we have
    \[ |ic2| |.->|^* |ic2''| |.->| |ic2'|
    \quad \land \quad |ic1'| \approx_{|il|} |ic2'| \text{.}\]
  \end{itemize}
\end{proof}
