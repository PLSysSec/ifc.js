\section{Generalizing to a CESK machine}
\label{sec:cesk}

Why is CSK not enough? Well if we want to write a correct condition
for label we need to make sure that if the target language is say just
STLC, then a lambda term that captures variables is properly handled.

(Definition of CESK)

Control-State-Environment-Kontinuations

** Insert definition from plt redex book **
We consider languages that can be modeled using imperatice SOS, with
an explicit store and evaluation contexts.




\paragraph{Conditions on label}
$\forall
\TE,
\Istore_1, \Il_1, \Ic_1,
\Istore_2, \Il_2, \Ic_2.
\Iconf{\Istore_1}{\Il_1}{\Ic_1}{\inTE{\Tv}} \Tarrow^* k
\Leftrightarrow              
\Iconf{\Tstore_2}{\Il_2}{\Ic_2}{\inTE{\Tv}} \Tarrow^* k
$
and\\
$
\Iconf{\Istore_1}{\Il_1}{\Ic_1}{\inTE{\Tv}} \Tarrow^*
\Iconf{\Istore'}{\Il'}{\Ic'}{\diverge}
\Leftrightarrow              
\Iconf{\Tstore_2}{\Il_2}{\Ic_2}{\inTE{\Tv}} \Tarrow^*
\Iconf{\Istore'}{\Il'}{\Ic'}{\diverge}
$

\begin{enumerate}
 \item What is this saying? In any evaluation context $\TE$ the value
 \Tv reduces to the same configuration regardless of the store (and
 environment).
 \item We must consider the evaluation in the combined language; this
 e.g., allows labeling already-labeled values.
 \item The typing rule $\forall \Delta, \Gamma. \Delta;\Gamma \vdash
 \Tv : \tau$ is necessary when we want to preserve the type of \Tv,
 but no sufficient (e.g., can have same values of same type, but
 different value in the store; hence, we also need the SOS condition).
 \item The simpler condition: $\cdot \vdash \Tv : \tau$ for typed
 langauges may be easier to user; in this case the embedder needs to
 only prove that this implies the SOS condition.
 \item Really we want to add a meta-level function $\nu: \Tv
 \rightharpoonup \Tv$; this allows adding more ``guards'' for what can
 be labled. In the case of Browbound, $\nu$ can, for example, throw an
 exception if the value is not a string, thus forcing the programmer
 to only pass in stringyfied data. In turn, proving that the condition
 holds for this subset of values (strings) is trivial.
 
\end{enumerate}

\paragraph{Conditions on fork}
If we do not allow sharing of state between threads then there is no
SOS condition for fork. We don't care if the term gets stuck in the
new thread because $\Tklone$ removed elements. However, we do need a
condition when we consider typed systems. The condition for this is
given in the typing rule for fork:
%\Ifork{\Il'}{(\IT{\Te})})
\begin{mathpar}
\inferrule
{
\Delta; \Gamma \vdash \Ie_1 : l\\
\Tklone_\Delta(\Delta); \Gamma \vdash \Ie_2 : \tau
}
{
\Delta; \Gamma \vdash \Ifork{\Ie_1}{\Ie_2} : \tau
}
\end{mathpar}

\Red{ds: Should we consider the case where the state is shared among
threads? If so, then we need to actually give an SOS condition. For
Browbound we don't need this because this model would correspond to
the event loop and we have our threads running with different global;
of course message handlers do share state, but we can handle this case
without changes (I think)}
