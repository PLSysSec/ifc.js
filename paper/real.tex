\section{Real world languages}
\label{sec:real}

In this section we consider the application of our embedding to 
real world target languages.
%
To illustrate the flexibility of our system and challenges in the
embedding we chose three mainstream languages---C, Haskell, and
JavaScript---that have vastly different features and properties.
%
We remark that we have implemented variants of our Haskell and
JavaScript embeddings, which are used in the Hails~\tocite{} and
SWAPI~\tocite{} systems; we leave the implementation of the IFC system
for C, as describe below, to future work.

\subsection{C}
\label{sec:real:c}

\subsection{Haskell}
\label{sec:real:hs}
While the C embedding closely resembles the specification language of
Section~\ref{sec:retrofit}, in our Haskell IFC embedding we leverage
Haskell's strong data abstraction and static type system, monadic
approach to effects, and lightweight concurrency to implement the
embedding in a more efficient manner, as library.

To this end, we define a new monad, |LIO|, that wraps Haskell's |IO|
monad---which allows for arbitrary effects---to associate labels with
threads (tasks) and restrict computational effects according to the
semantics of Section~\ref{sec:retrofit}.
%
The precise restrictions encode our IFC system as computations in the
|LIO| monad.
%
By wrapping |IO|, we can use Haskell's efficient implementation of
threads, channels, etc. (e.g., we use Haskell's \texttt{forkIO} to
fork a lightweight thread in the case of |fork|), in contrast to
defining them in a pure fashion (see Section~\ref{sec:monad}).

Importantly, this concrete implementation approach also directly
corresponds to the specification language.
%
Specifically, it is |specLang alpha targetLangHS|, for $|alpha| \in
|{roundrobinf, seqf}|$, with the pure subset of Haskell as to target
language |targetLangHS|, the subset of Haskell that additionally
contains the |LIO| monad (and corresponding |LIO| computations
encoding the language) as the IFC language.
%
Of course since our IFC system is implemented as a library in Haskell,
we must ensure that these languages are indeed the subsets of Haskell
we claim, i.e., while the concrete language is all of Haskell, we must
ensure that we can restrict programs to our subset of Haskell that
encodes the combined language.
%

To this end, we rely Haskell's strong data abstraction and type system
(as enforced by Safe Haskell~\cite{Terei:2012:SH:2364506.2364524}) to
ensure that arbitrary |IO| actions cannot be lifted into
|LIO|.\footnote{
Of course, our IFC guarantees only extend insofar as the program is
written as a computation in the |LIO| monad; a program written
directly in the |IO| monad can trivially violate information flow
control.
}
%
In other words, assuming |LIO| is implemented correctly, programs
written in the |LIO| monad cannot perform arbitrary |IO| actions
without breaking abstraction.
 
We refer the interested reader to~\tocite{icfp,haskellsymp} for
additional details on the various implementations of this system.
%
Here, we lastly remark that our work unifies these systems and
presents a proof of NI for such systems with asynchronous
communication primitives.


\subsection{JavaScript}
\label{sec:real:js}

JavaScript (JS), as specified by ECMAScript~\tocite{}, does not have any
built-in functionality for I/O.
%
Consequently, and in contrast to our C and Haskell embeddings, for
which we must eliminate external effects, the embedding for JS is
trivial.
%
Hence, as a first step, we implement the IFC language functionality in the
JS runtime and expose the new functions, e.g., |fork|, by attaching
them to the JS global object.
%
Importantly, each task runs a separate instances of this runtime.

Indeed this coarse-grained approach is already used by browsers in the
Worker API~\tocite{}, which provides client-side JS with primitives
for executing code in a separate thread, called a Worker.
%
Each Worker has a separate runtime with a fresh global object.
%
In turn, exchanging information between runtimes is accomplished with
message-passing, i.e., \texttt{postMessage}.
%
The message-passing approach is, in part, due to ECMAScript's lack
of well-defined semantics for concurrency.
%
Hence sharing and accessing objects such as the DOM across threads is
undefined.
%

Hence, our implementation provides 

\begin{itemize}
\item not completely unrealist; workers provide a similar world; we
  provide labeled workers

\item actual embeddings of JS have external effects; consider the browser
  case as in SWAPI
\begin{itemize}
   \item associate label with browsing context ~ task
   \item use CSP and sandbox flags to control external effects
   \item mediate communication by interposing on on postMessage
   argue that browsers already have to provide isolation guarantees
   between different compartments
\end{itemize}

\item talk about SWAPI's attach object feature that makes the concrete
  implementation more interesting
\end{itemize}


Of course, applications, such as browsers, that embed JavaScript
expose various features that perform external effects (again by
attaching them as objects to the JS global object).
%







\cut{

\subsection{Example: JavaScript}
\label{sec:real:javascript}

(NB:\ the JS spec refers to execution context and state; when we refer to
execution context, we refer to both the context AND the state)

(Some background on JavaScript versus ECMAScript, since ECMAScript
constitutes the semantics we're actually going to combine with
IFC;\ everything else has to be locked down or made IFC-specific).

(Lay out how ECMAScript semantics work. Execution context and syntax.
Don't go into too much detail.  Point out that the execution context/state
corresponds implementation-wise to a JavaEngine)
g
(Minimal IFC fragment.  Actually, this wants to be in the general section.
So specialize this some more?)

(Combined ECMAScript and IFC. Talk about serialization. Draw parallel to web
workers, note the similarity.)
}
