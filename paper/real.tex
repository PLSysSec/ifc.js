\section{Real world languages}
\label{sec:real}

In this section we consider the application of our embedding to 
real world target languages.
%
To illustrate the flexibility of our system and challenges in the
embedding we chose three mainstream languages---C, Haskell, and
JavaScript---that have vastly different features and properties.
%
We remark that we have implemented variants of our Haskell and
JavaScript embeddings, which are used in the Hails~\tocite{} and
SWAPI~\tocite{} systems; we leave the implementation of the IFC system
for C, as describe below, to future work.

\subsection{C}
\label{sec:real:c}

\subsection{Haskell}
\label{sec:real:hs}
While the C embedding closely resembles the specification language of
Section~\ref{sec:retrofit}, in our Haskell IFC embedding we leverage
Haskell's strong data abstraction and static type system, monadic
approach to effects, and lightweight concurrency to implement the
embedding in a more efficient manner, as library.

To this end, we define a new monad, |LIO|, that wraps Haskell's |IO|
monad---which allows for arbitrary effects---to associate labels with
threads (tasks) and restrict computational effects according to the
semantics of Section~\ref{sec:retrofit}.
%
The precise restrictions encode our IFC system as computations in the
|LIO| monad.
%
By wrapping |IO|, we can use Haskell's efficient implementation of
threads, channels, etc. (e.g., we use Haskell's \texttt{forkIO} to
fork a lightweight thread in the case of |fork|), in contrast to
defining them in a pure fashion (see Section~\ref{sec:monad}).

Importantly, this concrete implementation approach also directly
corresponds to the specification language.
%
Specifically, it is |specLang alpha targetLangHS|, for $|alpha| \in
|{roundrobinf, seqf}|$, with the pure subset of Haskell as to target
language |targetLangHS|, the subset of Haskell that additionally
contains the |LIO| monad (and corresponding |LIO| computations
encoding the language) as the IFC language.
%
Of course since our IFC system is implemented as a library in Haskell,
we must ensure that these languages are indeed the subsets of Haskell
we claim, i.e., while the concrete language is all of Haskell, we must
ensure that we can restrict programs to our subset of Haskell that
encodes the combined language.
%

To this end, we rely Haskell's strong data abstraction and type system
(as enforced by Safe Haskell~\cite{Terei:2012:SH:2364506.2364524}) to
ensure that arbitrary |IO| actions cannot be lifted into
|LIO|.\footnote{
Of course, our IFC guarantees only extend insofar as the program is
written as a computation in the |LIO| monad; a program written
directly in the |IO| monad can trivially violate information flow
control.
}
%
In other words, assuming |LIO| is implemented correctly, programs
written in the |LIO| monad cannot perform arbitrary |IO| actions
without breaking abstraction.
 
We refer the interested reader to~\tocite{icfp,haskellsymp} for
additional details on the various implementations of this system.
%
Here, we lastly remark that our work unifies these systems and
presents a proof of NI for such systems with asynchronous
communication primitives.


\subsection{JavaScript}
\label{sec:real:js}

JavaScript (JS), as specified by ECMAScript~\tocite{}, does not have any
built-in functionality for I/O.
%
Consequently, and in contrast to our C and Haskell embeddings---for
which we must eliminate external effects---the embedding for JS is
trivial.
%
As a first step, we directly implement |specLangJS roundrobinf| by
running multiple instances of the JS runtime, i.e., |targetLangJS|, in
separate OS-level threads.

Specifically, we implement the IFC language functionality in the JS
runtime, much like browser layout engines implement the DOM, and
expose the new functions, e.g., |fork|, by attaching them to the JS
global object.
%
Importantly, each task created with |fork| is execute in a separate
thread, running a separate, fresh instance of our modified JS runtime.
%
In the context of our formalism, this amounts to using |klone(tS) =
tS0|, where |tS0| is the global object corresponding to the standard
JS library (e.g., |tS0| contains \texttt{Object}, \texttt{Array},
etc.).

Since this implementation approach relies on multiple runtimes of the
language, sending arbitrary objects between tasks can result in
unexpected behavior, e.g., when the object contains reference.
%
Hence, as discussed in Section~\ref{sec:concrete} we restrict |send|
to expressions that can be marshalled as strings, i.e., structurally
clonable objects~\tocite{}.
%
In our formalization this amounts to restricting the IFC language rule
for |send| such that only strings can be shared:
%{
\newcommand{\str}{"string"}
%format tOf (e) = "\texttt{typeOf}("e")\texttt{ === \str}"
%format ttrue = "\texttt{true}"
\begin{mathpar}
\inferrule[JS-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie') , Q ]|\\
|ie = IT te|\\
|conf tS (tOf te) -> conf tS ttrue|
}
{|
iconf iS (fullconf id il tS (iniEi (send id' il' ie)), ldots)
.->
iS'; sched S (fullconf id il tS (iniEi unit), ldots)
|}
\end{mathpar}
%}
We remark that this is similar to the existing
\texttt{postMessage} API used for iframe and Worker
communications~\tocite{}.
%
Insomuch, that the SWAPI implementation provides an IFC version of
\texttt{postMessage}, defined in terms of |send|, that additionally
takes a label argument.

Unsurprisingly, our coarse-grained combined language approach has been
inspired by existing browser (security) architectures.
%
Browsers, for example, isolate pages of different origins by running
them in separate runtimes.
%
Similarly, they provide the Worker JS object~\tocite{}, which allows
JavaScript to execute code in separate threads with separate JS
runtimes (and fresh global objects).
%
In both cases, code relies on the \texttt{postMessage} message-passing
API for communication, similar to our system.\footnote{
  The message-passing approach is, in part, due to ECMAScript's lack
  of well-defined semantics for concurrency.
  %
  Hence sharing and accessing objects such as the DOM across Worker
  threads is undefined.
}
  
More interestingly, the SWAPI implementation directly leverages these
mechanisms to implement the semantics of |specLangJS roundrobinf|
without modifying the JS runtime or intrusively changing the browser
layout engine~\tocite{}.
%
However, a simple implementation of just associating a label with
Workers and browsing context (iframes and top-level pages) to enforce
IFC on the executing JavaScript is not sufficient.
%
The initial global object of a Worker contains the
\texttt{XMLHttpRequest} (XHR) object, while the global object of a
browsing context additionally contains the DOM, i.e., the global
object in a browser JS runtime is not simply |tS0|, above, and thus,
in both cases, JS code can trivially leak information (e.g., to the
network with XHR or persistent storage using the DOM).
%

To address this we use content security policy (CSP) and (iframe)
sandbox~\tocite{} to restrict external effects according to the label
of a task (Worker or browsing context), as describe
in~\tocite{}.
%
Of course, simply disallowing all external effects for all browsing
contexts would break most of the Web.
%
Hence SWAPI only enforces IFC, and thus restricts external effects,
when the JS code uses the new API.\footnote{
  Once a piece of code ``opts-in'' to use our IFC API, in addition to
  restricting external effects we interpose ``standard''
  \texttt{postMessage} communication to ensure that no information is
  leaked between contexts that have opted-in and those that have not.
}
%
Moreover, rather than disallowing all external effects, SWAPI allows
controlled network communication by leveraging the fact that web
pages already have an accompanying security policy: the same origin
policy.
%
Hence, for example, a Worker that has read data only sensitive to
\texttt{http://bank.ch} can communicate with this domain; only once
\texttt{http://aws.com} data is also included in the context will all
network requests be blocked.
%
Of course, this requires that we use a concrete label format to
express the policies; we refer the interested reader to~\tocite{} for
more details.
