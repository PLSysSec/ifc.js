\section{Concrete implementation}
\label{sec:concrete}

The operational semantics we have derived in the previous section
satisfy termination sensitive non-interference by design.  However,
these abstract semantics essentially require that different tasks
execute completely isolated.  For instance, for the mini-ML language,
this means that every task has it's own heap.  For practical
implementations this is often not desirable.  Instead, we would like to
more tightly couple the integration of the target and IFC
language by reusing existing infrastructure.  In the running example,
a concrete implementation might use a single global heap, and ensure
that references do not cross task boundaries, and thus preserving
non-interference.

In this section, we will detail an approach that allows one to implement
a concrete system differently from our proposal in the previous
section, and give conditions for when such a system preserves termination
sensitive non-interference.
We explain the idea for the single heap mini-ML language, and then
generalize to arbitrary systems.

\subsection{IFC-Mini-ML with a Single Heap}

Instead of using a configuration of the form
|iconf iS (fullconf id1 il1 tS1 ie1, fullconf id2 il2 tS2 ie2 ldots)|
where every task has its
own ML heap, we would like a single global heap as in
|oneheapiconf iS tS (oneheapfullconf id1 il1 ie1, oneheapfullconf id2 il2 ie2, ldots)|.
Furthermore, we keep up a fictional separation between the portions
of the global heap that tasks can use by forbidding references to
cross task boundaries. Most
of the operational rules can easily be adapted to work with these
new configurations.  In the abstract system, the \textsc{I-fork}
rule created a new heap for the new task to execute in.  Since we
want to forbid references to cross task boundaries, we do not modify
the global heap and instead add an additional premise that the forked
expression |ie| must not contain any references.
Finally, we add the same condition to the \textsc{I-send} rule.
Tasks that try to fork or send an expression that contains a
reference will now get stuck, and will stop executing by the
\textsc{I-noStep} rule.

\Red{Show the key rules here.}

As we have outlined the IFC-Mini-ML language with a single heap, we
effectively restrict the abstract semantics in some cases (namely
to not allow the passing of references) as well as using a different
way to represent the heap.  How can we be sure that these
new, \textit{concrete semantics} for our system still satisfy
termination-sensitive non-interference?

This isn't trivial, as it is not sound to add arbitrary additional
conditions on evaluation rules.  To see this, consider a contrived
concrete system where we add a premise to a reduction rule that
stops a task based on secret information.  Such a system will
not satisfy non-interference, as it allows other tasks on the
same level to observe the termination of that task and thus the
secret information which was used to decide if the task terminates
or not.
\Red{This last part is written poorly.  Let's do it better, or remove it.}

\subsection{Correctness of Concrete Semantics}

\Red{Say what do we do here.}

\Red{At some point in this section we should say a little about
  why the abstract setting needs complete isolation (because it
  works for \textit{any} language), and that this is sometimes
  what you want.}

\subsection{\Red{Previous Stuff (to be merged/removed as necessary)}}

The operational semantics we have derived in the previous section
constitutes an abstract \emph{specification}: a semantics for which
non-interference is (obviously) true.  This specification can guide the
design of an information-flow calculus which would not be directly
derivable from our procedure, but is related to some such derivation.
For example, in our mini-ML language, the combined semantics requires
each thread to have a separate ML heap.  In an actual implementation, we
might like to only have a single heap and disallow the passing of
references between threads.  This restriction maintains a correspondence
between the abstract multiple heaps and the concrete single heap.  We might
hope that we can prove noninterference for this new system by reusing
noninterference for the old system.

However, modifying operational rules poses a distinct problem for
preserving non-interference.  Consider a trivial state machine as shown
in Figure~\ref{fig:trivial-sm}, whose second projection is classified
secret.  With all three transitions, this language fulfills
termination-sensitive noninterference.  Furthermore, if the dashed line
is removed, the language continues to satisfy TSNI.  However, if any
solid line is removed, however, the language fails TSNI.

\begin{figure}
    States: $(x,y)$ for $x,y \in \{0,1\}$ \\
    Erasure function: $f(x,y) = (x,\bullet)$

    \begin{center}\begin{tikzpicture}[node distance=2cm, auto]
        \node (A) {$(1,1)$};
        \node (B) [right of=A] {$(1,0)$};
        \node (C) [below of=A] {$(0,1)$};
        \node (D) [right of=C] {$(0,0)$};
        \draw[->] (A) to node {} (B);
        \draw[->] (C) to node {} (D);
        \draw[->, dashed] (B) to node {} (D);
    \end{tikzpicture}\end{center}

    \label{fig:trivial-sm}
    \caption{A trivial state machine}
\end{figure}

The approach we will take is in two steps.  First, we sidestep the
restriction problem by demanding that the concrete implementation be
\emph{isomorphic} to the abstract specification, but perhaps having a different
runtime representation (a single heap) and some well-formedness
condition (every item on the heap only contains pointers from a single
location).  Isomorphism will preserve nonintereference, but it will also means all
transitions in the abstract language have to be implemented, including
undesirable transitions such as sending a pointer to another thread makes
the pointer dangling.  Next, we define a desugaring into this language
which adds dynamic checks, eliminating the possibility for these undesirable
transitions to be exercised.

\begin{theorem}[Isomorphism preserves termination sensitive non-interference]
    Consider a language \tar{L} with configurations |tc|, reduction
    relation \tar{|.->|} and erasure function \tar{|erasef l|} and a
    language \ifc{L} with configurations |ic|, reduction relation
    \ifc{|.->|} and erasure function \ifc{|erasef l|}.  We say that
    \tar{L} and \ifc{L} are isomorphic if there exist (total) functions
    $f : |tc -> ic|$ and $f^{-1} : |ic -> tc|$ such that $f \circ f^{-1}
    = id$, $f^{-1} \circ f^{-1} = id$, and that $f$ and $f^{-1}$ are
    functorial over $l$-equivalences (i.e. if $|tc|\ \tar{\approx_l}\
    |tc'|$ then $f(|tc|)\ \ifc{\approx_l}\ f(|tc'|)$ and vice-versa).
    Then if \ifc{L} satisfies termination sensitive non-interference,
    then \tar{L} satisfies termination sensitive non-interference.
\end{theorem}

\begin{proof}
    Easy application of TSNI \tar{L} by applying $f$
\end{proof}

\begin{figure}

\begin{mathpar}
\inferrule[I-stepT]
{|
conf tS (te) -> conf tS' te'
|}
{|
coconf iS tS (cconf id il (iniE (IT te)), ldots)
.->
iS ; tS' ; sched step (cconf id il (iniE (IT te')), ldots)
|}

\and
% This rule is not complete, needs the FV condition
\inferrule[C-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|it1 = cconf id il (iniE id')|\\
|itnew = cconf id' il (TI ie)|\\
|fresh (id')|
}
{|
coconf iS tS (lconf id il (iniE (fork ie)), ldots)
.->
iS'; tS; sched fork (it1, ldots, itnew)
|}
\end{mathpar}

\caption{ML with a single heap}
\label{fig:comb}
\end{figure}

This version
