\section{Concrete implementation}
\label{sec:concrete}

\newcommand{\con}[1]{\ensuremath{{\color{red} #1}}}
\newcommand{\abs}[1]{\ensuremath{{\color{blue} #1}}}

The operational semantics we have defined in the previous section
satisfy non-interference by design.
We achieve this general statement that works for a large class of
languages by having different tasks executing completely isolated from
each other, such that every task has its own state.
In some cases, this strong separation is desirable, or even necessary.
Languages like C provide direct access to memory locations without
mechanisms in the language to achieve a separation of the heap.
On the other hand, for other languages this
strong isolation of tasks can be
undesirable, e.g., for performance reasons.
For instance, for the language |targetLangML|, our presentation so far
requires a separate heap per task, which is not very practical.
Instead, we would like to
more tightly couple the integration of the target and IFC
language by reusing existing infrastructure.  In the running example,
a concrete implementation might use a single global heap.
More precisely, instead of using a configuration of the form
\[|iconf iS (fullconf id1 il1 tS1 ie1, fullconf id2 il2 tS2 ie2 ldots)|\]
we would like a single global heap as in
\[|oneheapiconf iS tS (oneheapfullconf id1 il1 ie1, oneheapfullconf id2 il2 ie2, ldots)|\]

If the operational rules are adapted na\"ively to this new setting,
then non-interference can be violated.  In particular, it is not
sound to share references to a heap cell between different tasks.
Otherwise, information can be trivially leaked by copying
secret data into a reference in one task, and then
reading it again by a another task with a lower label.
What we would like is a way of characterizing safe modifications to
the semantics which preserve non-interference.
The intention of our single heap implementation was to be more efficient
by using one global heap, but \emph{conceptually maintain isolation between
task by not allowing sharing of references between them}.
This intuition of having a different (potentially more efficient)
concrete semantics that behave like the abstract semantics
can be formalized by the following definition:

% con no-prime red target
% abs prime blue ifc

\begin{definition}[Isomorphism of information-flow control languages]
  A language |(C, .->, erasef l)| is \textit{isomorphic} to a
  language |(C', tarrow', erasefp l)| if there exist total functions |f
  : C -> C'| and |finv : C' -> C| such that |f .. finv = idf C| |finv
  .. f = idf C'|.  Furthermore, |f| and |finv| are functorial (e.g. if
  $x'\ R'\ y'$ then $f(x')\ R\ f(y')$) over both
  $l$-equivalences and |.->|.
  
  If we weaken this restriction such that |finv| does
  not have to be functorial over |.->|, we call the
  language |(C, .->, erasef l)| \textit{weakly isomorphic} to
  |(C', tarrow', erasefp l)|.
\end{definition}

Providing an isomorphism between the two languages allows us to
preserve (termination sensitive or insensitive) non-interference
as the following two theorems state.

\begin{theorem}[Isomorphism preserves termination sensitive non-interference]
  \label{thm:iso-tsni}
  If L is isomorphic to L' and L' satisfies TSNI, then
  L satisfies TSNI.
\end{theorem}

\begin{proof}
  Shown by transporting configurations and reduction derivations from
  L to L', applying TSNI, and then transporting the
  resulting configuration, $l$-equivalence and multi-step derivation back.
\end{proof}

\begin{theorem}[Weak isomorphism preserves termination insensitive non-interference]
  \label{thm:iso-tini}
  If a language L is weakly isomorphic to a language L', and L'
  satisfies TINI, then L satisfies TINI.
\end{theorem}

\begin{proof}
  Shown by transporting configurations and reduction derivations
  from L to L', applying TINI and transporting the resulting
  equivalence back using functoriality of |finv| over $l$-equivalences.
\end{proof}


To obtain an isomorphism with our single heap semantics, we need to mimic the
behavior of several heaps into one. The interesting cases are when forking and
sending or receiving messages. These rules (see Section~\ref{sec:retrofit}) are
parameterized by the strategy |klone|, which defines what heap the new task
should execute with.  We have motivated two choices, namely the identity (to
effectively clone the heap), or to start with an empty heap.  

In the first choice, the concrete semantics should essentially implement several
heaps into one. For that, it creates a copy of everything reachable from the
forked expression (not just the values for the memory addresses in the
expression \Red{Ale:why not only the addresses?}), and replace all addresses
correspondingly.  behavior of sending a memory address now depends on whether
that address existed at the time the receiving task was forked; if it did, then
the address should be rewritten to the new one, otherwise to a fresh one.


In the latter case, this effectively means that the concrete semantics must
change the forked expression |ie| in such a way that all addresses get rewritten
to fresh addresses that are guaranteed to not occur in the global heap. As a
consequence, existing addresses in the forked expression |ie| are no longer
valid and the task gets stuck (and then removed by \textsc{I-noStep}).
%\todo{}{Is this actually true?  Currently the semantics are unclear.}
%To get the isomorphic behavior in the concrete semantics with a
%single heap, we would have to change the forked expression |ie| in
%such a way that all addresses get rewritten to fresh addresses
%that are guaranteed to not occur in the global heap.  
Similarly, sending a memory address should take a similar approach, as addresses
for sent references will not exist in the receiving task.


% A na\"ive attempt at our single heap semantics
% will not allow us to construct an isomorphism
% with the abstract language |specLangML alpha|, and instead highlights
% where things will go wrong.
% To successfully construct an isomorphism, our concrete semantics need
% to mirror the behavior of the abstract semantics, most importantly
% in the case where tasks interact.  Namely, at a fork and when sending
% or receiving messages, we take an expression from one task and
% execute it in the context of another task.  In the abstract semantics
% the fork rule is parameterized by the strategy |klone|, which defines
% what heap the new task should execute in.  \Red{In Section~\ref{sec:retrofit}
% we have motivated two choices}, namely the identity (to effectively
% clone the heap), or to start with an empty heap.
% In the latter case, this effectively means that existing addresses
% in the forked expression |ie| are no longer valid and the
% task gets stuck (and then removed by \textsc{I-noStep}).
% \todo{}{Is this actually true?  Currently the semantics are unclear.}
% To get the isomorphic behavior in the concrete semantics with a
% single heap, we would have to change the forked expression |ie| in
% such a way that all addresses get rewritten to fresh addresses
% that are guaranteed to not occur in the global heap.  Similarly,
% sending a memory address should take a similar approach, as addresses
% for sent references will not exist in the receiving task.

% If |klone| is the identity function, then the abstract semantics
% effectively clone the heap on a fork.  To get an isomorphic
% behavior in the concrete, we would have to create a copy of everything
% reachable from the forked expression (not just the values for
% the memory addresses in the expression), and replace all addresses
% correspondingly.  Even worse, the behavior of sending a memory address
% now depends on whether that address existed at the time the receiving
% task was forked;  if it did, then the address should be rewritten to the
% new one, otherwise to a fresh address.
% Such a complicated behavior is contradictory to our initial motivation
% of implementing a single heap for efficiency.  But also the
% behavior of the simpler case where |klone| returns an empty heap is
% undesirable:  We rewrite addresses to fresh addresses, which will
% result in a stuck task whenever such an address is dereferenced.

\subsection{Restricting the IFC Language}

As a better solution we could forbid forked expressions as well
as messages sent to other tasks to contain memory addresses in the
first place.  In a statically typed language, the type system could
prevent this from happening, and we talk more about how our
approach integrates with typed languages in
Section~\ref{sec:extensions:types}.
In a dynamically type languages such as |targetLangML|, we might
restrict the transition for |fork| and |send| to only allow expressions
without memory addresses.

Generally speaking, we are modifying the IFC language semantics in a non-trivial
way, which begs the question whether non-interference is preserved.  With this
in mind, we device a general condition under which restrictions on transitions
preserve non-interference. We require semantic rules to get restricted only
based on information observable by the task triggering them. In that manner, the
restriction does not depend on confidential information---a possible risk to
jeopardize security. Below, the formal definition of such conditions for the
abstract IFC language |specLang alpha targetLang|.

%, such that non-interference is preserved.


%system in general does not preserve non-interference as the following
%minimal example illustrates. 


% Again, we are modifying the IFC language semantics in a non-trivial way,
% which begs the question whether non-interference is preserved.
% Restricting the transitions in an information flow control
% system in general does not preserve non-interference as the following
% minimal example illustrates. \Red{Ale: I am not sure that the example is clear,
%   too abstract, at least, I don't get it. Propose to remove it, and just say 
% the top level idea: ``the restriction should not be based on secret data!''} 
% Consider a trivial state machine as shown
% in Figure~\ref{fig:trivial-sm}, whose second projection is classified
% secret.  With all three transitions, this language fulfills
% termination sensitive non-interference.  Furthermore, if the
% dashed transition
% is removed, the language continues to satisfy TSNI.  However, if any
% solid line is removed, the language fails TSNI.

% \begin{figure}
%   States: $(x,y)$ for $x,y \in \{0,1\}$ \\
%   Erasure function: $f(x,y) = (x,\bullet)$
  
%   \begin{center}\begin{tikzpicture}[node distance=2cm, auto]
%     \node (A) {$(1,1)$};
%     \node (B) [right of=A] {$(1,0)$};
%     \node (C) [below of=A] {$(0,1)$};
%     \node (D) [right of=C] {$(0,0)$};
%     \draw[->] (A) to node {} (B);
%     \draw[->] (C) to node {} (D);
%     \draw[->, dashed] (B) to node {} (D);
%     \end{tikzpicture}\end{center}
  
%   \label{fig:trivial-sm}
%   \caption{A trivial state machine}
% \end{figure}

%To remedy this issue, 

\begin{definition}[Restricted IFC language]
  \label{def:restricted}
  For a family of predicates $\mathcal P$ (one for every reduction
  rule), we call
  |restrictedLang alpha targetLang| a restricted IFC language
  if its definition is equivalent to the abstract language
  |specLang alpha targetLang|, with the following exception:
  The reduction rules are restricted
  by adding a predicate $P \in \mathcal P$ to the premise of
  all rule other than \textsc{I-noStep}.  Furthermore, the predicates $P$
  can depend only on the \textit{erased} configuration
  |erase il ic|, where |il| is the label of the first task
  in the task list and |ic| the full configuration.
\end{definition}

By the following theorem, the restricted IFC language with an
appropriate scheduling policy is non-interfering.

\begin{theorem}
  \label{thm:restricted}
  For any target language |targetLang| and family of predicates
  $\mathcal{P}$, the restricted IFC language |restrictedLang roundrobinf targetLang|
  is TSNI.  Furthermore, the IFC language
  |restrictedLang seqf targetLang| is TINI.
\end{theorem}


\subsection{IFC language with a single heap}

We are now ready to make our single heap IFC language precise and
ensure its non-interference using the techniques presented.
First, we can construct the restricted language
|restrictedLangNoRef alpha targetLangML|, where |noRefs| is
the family of always valid predicates, except for the ones for
\textsc{I-fork} and \textsc{I-send}, which we define as
\[ P(e) = \text{|ie| does not contain any address |ta|} \]
That is, we do not restrict any rules except for \textsc{I-fork}
and \textsc{I-send}.
Since $P$ only depends on |ie|, which is part of the current
task and thus never erased w.r.t.\ the label of the first task,
this language satisfies non-interference by Theorem~\ref{thm:restricted}.

\begin{figure}
  
  \begin{mathpar}
    \inferrule[C-fork]
    {
      \text{|ie| does not contain any |ta|}\\
      |iS' = bracket iS (mapsto id' nil)|\\
      |it1 = oneheapfullconf id il (iniE id')|\\
      |itnew = oneheapfullconf id' il (TI ie)|\\
      |fresh (id')|
    }
    {|
      oneheapiconf iS tS (oneheapfullconf id1 il1 (iniEi (fork ie)), ldots)
      .->
      iS'; tS; sched F (it1, ldots, itnew)
    |}
    \and
    \inferrule[C-send]
    {
      \text{|ie| does not contain any |ta|}\\
      |canFlowTo2 il il'|\\
      |iS(id') = Q|\\
      |iS' = bracket iS (mapsto id' (il', id,  ie) , Q)|
    }
    {|
      oneheapiconf iS tS (oneheapfullconf id il (iniEi (send id' il' ie)), ldots)
      ->
      iS; tS; sched step (oneheapfullconf id il unit, ldots)
    |}
  \end{mathpar}
  
  \caption{A selection of the reduction rules for |concreteLangMl alpha|.}
  \label{fig:concrete}
\end{figure}

The essential parts of the semantics for the concrete language
with a single heap,
which we call |concreteLangMl alpha|,
are given in Figure~\ref{fig:concrete}.  Most rules are
straight-forward translations of the rules in Figures~\ref{fig:ifc}
and~\ref{fig:embedding} but for a single heap.  For conciseness, we
only show the interesting ones.
Now, we can show an isomorphism between this language and
|restrictedLangNoRef alpha targetLangML|, which
(by Theorem~\ref{thm:iso-tsni} and~\ref{thm:iso-tini}) guarantees
non-interference for an appropriate scheduling policy |alpha|.

\Red{Show the isomorphism.}



