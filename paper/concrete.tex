\section{Concrete implementation}
\label{sec:concrete}

\newcommand{\con}[1]{\ensuremath{{\color{red} #1}}}
\newcommand{\abs}[1]{\ensuremath{{\color{blue} #1}}}

The operational semantics we have defined in the previous section
satisfy non-interference by design.
We achieve this general statement that works for a large class of
languages by having different tasks executing completely isolated from
each other, such that every task has its own state.
In some cases, this strong separation is desirable, or even necessary.
Languages like C provide direct access to memory locations without
mechanisms in the language to achieve a separation of the heap.
On the other hand, for other languages this
strong isolation of tasks can be
undesirable, e.g., for performance reasons.
For instance, for the language |targetLangML|, our presentation so far
requires a separate heap per task, which is not very practical.
Instead, we would like to
more tightly couple the integration of the target and IFC
language by reusing existing infrastructure.  In the running example,
a concrete implementation might use a single global heap.
More precisely, instead of using a configuration of the form
\[|iconf iS (fullconf id1 il1 tS1 ie1, fullconf id2 il2 tS2 ie2 ldots)|\]
we would like a single global heap as in
\[|oneheapiconf iS tS (oneheapfullconf id1 il1 ie1, oneheapfullconf id2 il2 ie2, ldots)|\]

If the operational rules are adapted na\"ively to this new setting,
then non-interference can be violated.  In particular, it is not
sound to share references to a heap cell between different tasks.
Otherwise, information can be trivially leaked by copying
secret data to a shared reference in one task, and then
reading it again by a another task with a lower label.
What we would like is a way of characterizing safe modifications to
the semantics which preserve non-interference.
The intention of our single heap implementation was to be more efficient
by using one global heap, but \emph{conceptually maintain isolation between
task by not allowing sharing of references between them}.
This intuition of having a different (potentially more efficient)
concrete semantics that behave like the abstract semantics
can be formalized by the following definition:

% con no-prime red target
% abs prime blue ifc

\begin{definition}[Isomorphism of information-flow control languages]
  A language |(C, .->, erasef l)| is \textit{isomorphic} to a
  language |(C', tarrow', erasefp l)| if there exist total functions |f
  : C -> C'| and |finv : C' -> C| such that |f .. finv = idf C| |finv
  .. f = idf C'|.  Furthermore, |f| and |finv| are functorial (e.g. if
  $x'\ R'\ y'$ then $f(x')\ R\ f(y')$) over both
  $l$-equivalences and |.->|.
  
  If we weaken this restriction such that |finv| does
  not have to be functorial over |.->|, we call the
  language |(C, .->, erasef l)| \textit{weakly isomorphic} to
  |(C', tarrow', erasefp l)|.
\end{definition}

Providing an isomorphism between the two languages allows us to
preserve (termination sensitive or insensitive) non-interference
as the following two theorems state.

\begin{theorem}[Isomorphism preserves termination sensitive non-interference]
  \label{thm:iso-tsni}
  If L is isomorphic to L' and L' satisfies TSNI, then
  L satisfies TSNI.
\end{theorem}

\begin{proof}
  Shown by transporting configurations and reduction derivations from
  L to L', applying TSNI, and then transporting the
  resulting configuration, $l$-equivalence and multi-step derivation back.
\end{proof}

\begin{theorem}[Weak isomorphism preserves termination insensitive non-interference]
  \label{thm:iso-tini}
  If a language L is weakly isomorphic to a language L', and L'
  satisfies TINI, then L satisfies TINI.
\end{theorem}

\begin{proof}
  Shown by transporting configurations and reduction derivations
  from L to L', applying TINI and transporting the resulting
  equivalence back using functoriality of |finv| over $l$-equivalences.
\end{proof}

Unfortunately, an isomorphism is often too strong of a requirement.
To obtain an isomorphism with our single heap semantics, we need to mimic the
behavior of several heaps with a single actual heap.
The interesting cases are when we sandbox
an expression and when messages are sent and received.
The rule for sandboxing is
parameterized by the strategy |klone| (cf.\ Section~\ref{sec:retrofit}),
which defines what heap the new task
should execute with.  We have considered two choices:

\begin{itemize}
    \item When we sandbox into an empty heap, existing addresses
in the forked expression are no longer valid and the
task will get stuck (and then removed by \textsc{I-noStep}).
Thus, we must rewrite the forked expression so that
all addresses point to fresh addresses
guaranteed to not occur in the heap.  Similarly,
sending a memory address should be rewritten.

\item When we clone the heap, we have to create a copy of everything
reachable from the forked expression (not just the values for
the memory addresses in the expression), and replace all addresses
correspondingly.  Even worse, the behavior of sending a memory address
now depends on whether that address existed at the time the receiving
task was forked;  if it did, then the address should be rewritten to the
new one, otherwise to a fresh address.
\end{itemize}

This complicated behavior is counter to our initial motivation
of implementing a single heap for efficiency.



\subsection{Restricting the IFC Language}

A better solution is to forbid forked expressions as well
as messages sent to other tasks to contain memory addresses in the
first place.  In a statically typed language, the type system could
prevent this from happening, and we talk more about how our
approach integrates with typed languages in
Section~\ref{sec:extensions:types}.
In a dynamically type languages such as |targetLangML|, we might
restrict the transition for |fork| and |send| to only allow expressions
without memory addresses.

While this sounds plausible, it is worth noting that we are modifying the IFC language semantics,
which raises the question whether non-interference is preserved.
This question can be subtle: it is easy to remove a transition from
a language and invalidate TSNI.  Intuitively
if the restriction depends on secret data, then a public thread
can observe if some other task terminates or not, and by that obtain
information about the secret data that was used to restrict the
transition.
With this in mind, we require semantic rules to get restricted only
based on information observable by the task triggering them.
This ensures that non-interference is preserved, as the
restriction does not depend on confidential information.
Below, we give the formal definition of this condition for the
abstract IFC language |specLang alpha targetLang|.

%system in general does not preserve non-interference as the following
%minimal example illustrates. 


% Again, we are modifying the IFC language semantics in a non-trivial way,
% which begs the question whether non-interference is preserved.
% Restricting the transitions in an information flow control
% system in general does not preserve non-interference as the following
% minimal example illustrates. \Red{Ale: I am not sure that the example is clear,
%   too abstract, at least, I don't get it. Propose to remove it, and just say 
% the top level idea: ``the restriction should not be based on secret data!''} 
% Consider a trivial state machine as shown
% in Figure~\ref{fig:trivial-sm}, whose second projection is classified
% secret.  With all three transitions, this language fulfills
% termination sensitive non-interference.  Furthermore, if the
% dashed transition
% is removed, the language continues to satisfy TSNI.  However, if any
% solid line is removed, the language fails TSNI.

% \begin{figure}
%   States: $(x,y)$ for $x,y \in \{0,1\}$ \\
%   Erasure function: $f(x,y) = (x,\bullet)$
  
%   \begin{center}\begin{tikzpicture}[node distance=2cm, auto]
%     \node (A) {$(1,1)$};
%     \node (B) [right of=A] {$(1,0)$};
%     \node (C) [below of=A] {$(0,1)$};
%     \node (D) [right of=C] {$(0,0)$};
%     \draw[->] (A) to node {} (B);
%     \draw[->] (C) to node {} (D);
%     \draw[->, dashed] (B) to node {} (D);
%     \end{tikzpicture}\end{center}
  
%   \label{fig:trivial-sm}
%   \caption{A trivial state machine}
% \end{figure}

%To remedy this issue, 

\begin{definition}[Restricted IFC language]
  \label{def:restricted}
  For a family of predicates $\mathcal P$ (one for every reduction
  rule), we call
  |restrictedLang alpha targetLang| a restricted IFC language
  if its definition is equivalent to the abstract language
  |specLang alpha targetLang|, with the following exception:
  The reduction rules are restricted
  by adding a predicate $P \in \mathcal P$ to the premise of
  all rule other than \textsc{I-noStep}.  Furthermore, the predicates $P$
  can depend only on the \textit{erased} configuration
  |erase il ic|, where |il| is the label of the first task
  in the task list and |ic| the full configuration.
\end{definition}

By the following theorem, the restricted IFC language with an
appropriate scheduling policy is non-interfering.

\begin{theorem}
  \label{thm:restricted}
  For any target language |targetLang| and family of predicates
  $\mathcal{P}$, the restricted IFC language |restrictedLang roundrobinf targetLang|
  is TSNI.  Furthermore, the IFC language
  |restrictedLang seqf targetLang| is TINI.
\end{theorem}


\subsection{IFC language with a single heap}

We are now ready to make our single heap IFC language precise and
ensure its non-interference using the techniques presented.
First, we can construct the restricted language
|restrictedLangNoRef alpha targetLangML|, where |noRefs| is
the family of always valid predicates, except for the ones for
\textsc{I-fork} and \textsc{I-send}, which we define as
\[ P(|ie|) = (\mathcal{AV}(|ie|) = \emptyset{}) \]
where $\mathcal{AV}(|ie|)$ denotes the set of address variables in |ie|.
That is, we do not restrict any rules except for \textsc{I-fork}
and \textsc{I-send}.
Since $P$ only depends on |ie|, which is part of the current
task and thus never erased w.r.t.\ the label of the first task,
this language satisfies non-interference by Theorem~\ref{thm:restricted}.

\begin{figure}
  
  \begin{mathpar}
    \inferrule[C-fork]
    {
      \mathcal{AV}(|ie|) = \emptyset{}\\
      |iS' = bracket iS (mapsto id' nil)|\\
      |it1 = oneheapfullconf id il (iniE id')|\\
      |itnew = oneheapfullconf id' il (TI ie)|\\
      |fresh (id')|
    }
    {|
      oneheapiconf iS tS (oneheapfullconf id1 il1 (iniEi (fork ie)), ldots)
      .->
      iS'; tS; sched F (it1, ldots, itnew)
    |}
    \and
    \inferrule[C-send]
    {
      \mathcal{AV}(|ie|) = \emptyset{}\\
      |canFlowTo2 il il'|\\
      |iS(id') = Q|\\
      |iS' = bracket iS (mapsto id' (il', id,  ie) , Q)|
    }
    {|
      oneheapiconf iS tS (oneheapfullconf id il (iniEi (send id' il' ie)), ldots)
      ->
      iS; tS; sched step (oneheapfullconf id il unit, ldots)
    |}
  \end{mathpar}
  
  \caption{A selection of the reduction rules for |concreteLangMl alpha|.}
  \label{fig:concrete}
\end{figure}

The essential parts of the semantics for the concrete language
with a single heap,
which we call |concreteLangMl alpha|,
are given in Figure~\ref{fig:concrete}.  Most rules are
straight-forward translations of the rules in Figures~\ref{fig:ifc}
and~\ref{fig:embedding} but for a single heap.  For conciseness, we
only show the interesting ones.
Now, we can show an isomorphism between this language and
|restrictedLangNoRef alpha targetLangML|, which
(by Theorem~\ref{thm:iso-tsni} and~\ref{thm:iso-tini}) guarantees
non-interference for an appropriate scheduling policy |alpha|.

To this end, we represent addresses in the concrete language as
pairs $(|id|,|ta|)$ where |id| is a task identifier, and |ta| an
address in the abstract system\footnote{Note that this does
  not make the isomorphism trivial, as in the single heap, there
  is nothing preventing task 1 to access an address (2,|ta|).
  Furthermore, it is common to represent addresses in this way
  for efficient garbage collection of dead tasks.}.
We also formulate the following well-formedness condition for
configurations:
\[
  |wf c| = \forall |oneheapfullconf id il ie| \in |ic|.\ 
  \{ (|id'|,|ie'|) \in \mathcal{AV}(|ie|) \ \vert\ |id| \neq |id'| \} = \emptyset
\]
Essentially, every address in a given task must have the correct
identifier as the first part of the address.  It is easy to
see that the initial configuration satisfies this condition, and
any step in the concrete semantics preserves the condition.
Therefore, we only need to consider well-formed configurations,
which allows us to give the two required functions
|f| and |finv| for the isomorphism.  For conciseness, we informally
give their definition and leave the straight-forward proof that they
actually provide an isomorphism.
\begin{itemize}
  \item Addresses can be directly translated with
  $|f|((|id|,|ta|))=|ta|$, and $|finv|(|ta|)=|(id,ta)|$ for
  an address |ta| that occurs in task |id|.
  \item |f| splits the single heap into multiple heaps based on
  the |id| of the addresses.  |finv| produces a single heap
  by translating the addresses and collapsing everything to a single
  store.
\end{itemize}

