\section{A simple embedding}
\label{sec:example}

To get the flavor for our approach, we will first show how our embedding
works for a simple, ML-like language, with references and general recursion.

\begin{figure}
\begin{verbatim}
e ::= e e
    | x
    | ref e
    | !e
    | e := e
    | fix e
    | if e then e else e
    | v

v ::= \ x . e
    | #t
    | #f
    | a
\end{verbatim}
\label{fig:ml}
\end{figure}

(Selected rules from evaluation semantics. It's typed in the usual way.)

(Maybe this section needs to get moved) Sketch how a traditional account
of IFC would go about extending these rules.  These things are:

\begin{enumerate}
    \item Extend values with labels. (Values are isolated in runtimes,
        so runtime is labeled not values)
    \item Extend semantics to have a label on the program counter.
        (Ditto, runtime is values.)
    \item Extend semantics for assignment, as addresses need labels.
        (Labeled references are internalized in IFC language, and
        traditional references are isolated in runtimes.)
    \item Flow-sensitivity/insensitivity? (We choose flow-insensitive,
        flow sensitivity by reduction.)
\end{enumerate}

% No longer describing a "minimal non-Turing complete IFC calculus",
% instead, we jump straight to the combination.

We'd like to construct a coarse-grained IFC system on top of our language.
Intuitively, programs written in the target language are running on top of
an IFC ``operating system''.  The way we will perform our embedding is
by allowing programs to perform ``syscalls'' into the IFC runtime, and
vice-versa.  The IFC runtime is responsible for performing label checks
and ensuring TSNI is not violated.

We achieve this using a Matthews-Findler style embedding~\nocite{} to combine
the IFC language from the previous section with our example language.  Key points:

\Red{EZY reviewer hat: why is this type mediation necessary? It seems a bit
over-the-top.}

\begin{itemize}
    \item Expression and evaluation contexts are considered separately,
        so that some of our operational rules are easier to write
    \item IT/TI mediate cross-language type boundary (mention that this
        is where monitor failure/exceptions get handled)
\end{itemize}

First, we associate a label with every evaluation context.  Suppose you had
a function \verb|readFile|, you need to raise your label to write this
kind of program.

Motivate why we have labeled values. How to I avoid label creep problem? We
have fork. \Red{EZY shouldn't be in the ``background'' section.}

\Red{Give a fake rule with how you raise your label when you read from a file.
We give you labeled values explicitly.}

\Red{EZY Why wouldn't a reviewer say, this sendMessage/receiveMessage thing
is pretty weird, why'd you do the API that way?}

\begin{verbatim}
% colored differently
e ::= fork e
    # let's do channels?
    | sendMessage e e  # asynchronous
    | receiveMessage e # registers the callback
    | label e e
    | unlabel e
    | IT e

v ::= tid
    | l
    | Labeled l v
\end{verbatim}

\Red{Prove type safety for combined language?}

\Red{Problem: synchronization primitives which are blocking. OK, talk
about this at the end. You can do whatever you want.}
% NB: the nice thing about sendMessage is we can just drop messages
% when the labels don't work out
%
% Intuitively, it would seem to me that any concurrency primitive
% would be fine, as long as you proved it safe, we don't really care.

(Full operational semantics. Provide type rules.)

\Red{What to do when you get stuck when you are about to invalidate IFC}


