\section{The methodology (XXX fix title)}
\label{sec:methodology}

We now formally state our information-flow control transformation.  For
simplicity's sake, we consider only single-threaded source languages,
whose primary notion of execution is evaluation of an expression into a
value.  (Later, we consider how to accomodate systems which have
semantics for concurrent execution.)

\subsection{A tiny information-flow control calculus}

\begin{figure}[h]
\begin{align*}
\textrm{Thread \#:}   && \Ii          &   \\
\textrm{Label:}       && \Il          &   \\
\textrm{Label op:}    && \ifc{\oplus} & ::=  \ifc{\lub}
                                        \ |\ \ifc{\glb}
                                        \ |\ \ifc{\flows}\\
\textrm{Value:}       && \Iv          & ::=  \Itrue 
                                        \ |\ \Ifalse
                                        \ |\ \Il
                                        \ |\ \Ierr
                                        \ |\ \Ii\\
%                                        \ |\ \IT{\Tv}{\Tstore}{\Tenv}\\
\textrm{Expression:}  && \Ie          & ::=  \Iv
                                        \ |\ \Ilop{\Ie}{\Ie}
                                        \ |\ \IgetLabel
                                        \ |\ \IgetClr\\&&&
                                        \ |\ \Ifork{\Ie}{\Ie}
                                        \ |\ \IT{\Te}\\
\textrm{Context:}     && \IE          & ::=  \Ihole{\ }
                                        \ |\ \Ilop{\IE}{\Ie}
                                        \ |\ \Ilop{\Iv}{\IE}\\&&&
                                        \ |\ \Ifork{\IE}{\Ie}
                                        \ |\ \Ifork{\Iv}{\IE}
                                        \ |\ \IT{\TE}\\
\textrm{Prim label op:} && \denot{\ }   & \in \Ie \rightharpoonup \Il \\
\end{align*}
% reduction rules
\begin{mathpar}

% reduce pure terms
\inferrule[E-pure]
{ 
\Ie_1 \Rto \Ie_2
}
{
\Iconf{\Il_1}{\Il_2}{\inIE{\Ie_1}}\|\cdots
\to
\Iconf{\Il_1}{\Il_2}{\inE{\Ie_2}}\|\cdots
}

\and

%label ops
\inferrule[E-labelOp]
{ }
{
\Ilop{\Il_1}{\Il_2}
\Rto
\denot{ \Ilop{\Il_1}{\Il_2}}
}

% fork
\inferrule[E-fork]
{ 
\Iflows{\Il_1}{\Il} \Rto \Itrue\\
\Iflows{\Il}{\Il_2} \Rto \Itrue\\
\Tstore' = \Tklone{\Tstore}(\Tstore)\\
\Tenv'   = \Tklone{\Tenv}(\Tenv)
}
{
\Iconf{\Il_1}{\Il_2}{\inIE{
  \Ifork{\Il}{\IT{\STI{\Ie}{\Tstore}{\Tenv}}}
}}\|\cdots
\to
\Iconf{\Il_1}{\Il_2}{\inE{\Ii}}\|\cdots\|
\Iconf{\Il_1}{\Il}{\inE{
  \IT{\STI{\Ie}{\Tstore'}{\Tenv'}}
}}\|\cdots
}{fresh(\Ii)}

\and
\inferrule[T-run]
{}
{
\inIE{ \SIT{\TI{\Ie}}{\Tstore}{\Tenv} }
\to
\inE{ \Ie }
}{}

\end{mathpar}

\caption{IFC calculus}
\end{figure}

\begin{figure}[h]
\begin{align*}
\textrm{Address:}     && \Ta          & \\
\textrm{Variable:}    && \Tx          & \\
\textrm{Value:}       && \Tv          & ::= \Tclo{\Tlambda{\Tx}{\Te}}{\Tenv}\\
\textrm{Expression:}  && \Te          & ::=  \Tv
                                        \ |\ \Tlambda{\Tx}{\Te}
                                        \ |\ \Tx
                                        \ |\ \Te\ \Te
                                        \ |\ \Tset{\Te}{\Te}
                                        \ |\ \TI{\Ie}
                                        \ |\ \STI{\Ie}{\Tstore}{\Tenv}\\
\textrm{Context:}     && \TE          & ::=  \Thole{\ }
                                        \ |\ \TE\ \Te
                                        \ |\ \Tv\ \TE\\&&&
                                        \ |\ \Tset{\TE}{\Te}
                                        \ |\ \Tset{\Tx}{\TE}
                                        \ |\ \TI{\IE}{\Tstore}{\Tenv}\\
\textrm{Environment:} && \Tenv        & \in \Tx \rightharpoonup \Ta \\
\textrm{Store:}       && \Tstore      & \in \Ta \rightharpoonup \Tv \\
\textrm{Klone:}       && \Tklone{X}   & \in X \rightharpoonup X, X \in \{\Tenv, \Tstore \} \\
\end{align*}
% reduction rules
\begin{mathpar}

% lambda to closure
\inferrule[T-lam]{ }
{
\Tconf{\Tstore}{\Tenv}{\inTE{\Tlambda{\Tx}{\Te}}}
\to
\Tconf{\Tstore}{\Tenv}{\inE{\Tclo{\Tlambda{\Tx}{\Te}}{\Tenv}}}
}

\and

% lookup variable
\inferrule[T-var]{ }
{
\Tconf{\Tstore}{\Tenv}{\inTE{\Tx}}
\to
\Tconf{\Tstore}{\Tenv}{\inE{\Tstore(\Tenv(\Tx))}}
}

% beta reduction
\inferrule[T-$\beta$]
{
\Tstore'=\Tstore[\Ta \mapsto \Tv]\\
\Tenv'' =\Tenv'[\Tx \mapsto \Ta]
}
{
\Tconf{\Tstore}{\Tenv}{\inTE{\Tclo{\Tlambda{\Tx}{\Te}}{\Tenv'}\ \Tv}}
\to
\Tconf{\Tstore'}{\Tenv''}{\inE{\Te}}
}{fresh(\Ta)}

\and

% set!
\inferrule[T-set]
{
\tar{\store'} = \Tstore[\Tenv(\Tx) \mapsto \Tv]
}
{
\Tconf{\Tstore}{\Tenv}{\inTE{\Tset{\Tx}{\Tv}}}
\to
\Tconf{\tar{\store'}}{\Tenv}{\inE{\Tv}}
}

\and

\inferrule
{ }
{
\Tconf{\Tstore}{\Tenv}{\inTE{\upcall{\ \Ie}}}
\to
\Tconf{\Tstore}{\Tenv}{\inTE{\upcall{^{\Tstore}_{\Tenv}\ \Ie}}}
}

\and

\inferrule
{
}
{
\Tconf{\Tstore}{\Tenv}{\inTE{\upcall{^{\Tstore'}_{\Tenv'}\ 
                              (\downcall{^{\Tstore''}_{\Tenv''} \Te})}}}
\to
\Tconf{\Tstore''}{\Tenv''}{\inE{\Te}}
}

\and
% fork
\inferrule[E-fork]
{ 
\Iflows{\Il_1}{\Il} \Rto \Itrue\\
\Iflows{\Il}{\Il_2} \Rto \Itrue\\
\Tstore' = \Tklone{\Tstore}(\Tstore)\\
\Tenv'   = \Tklone{\Tenv}(\Tenv)
}
{
\Iconf{\Il_1}{\Il_2}{\inIE{ \Ifork{\Il}{
      (\downcall{(\upcall{^{\Tstore}_{\Tenv}\ \Ie})})
}}}\|\cdots
\to
\Iconf{\Il_1}{\Il_2}{\inE{\Ii}}\|\cdots\|
\Iconf{\Il_1}{\Il}{\inE{
}}\|\cdots
}{fresh(\Ii)}


\end{mathpar}
\caption{Simple calculus}
\end{figure}

Our first task is to define a information-flow control mini-language
which will be combined with the source language. (Reference)  This
language is not Turing-complete; this is intentional, as (1) the ability
to call across the language boundary means that any control flow can be
implemented in the source language, and (2) it simplifies the
non-interference proof.  The language has a very simple set of typing
rules.  The operational semantics for this language are worth remarking
on (write a bit about how this IFC system works).  We can now state and
prove a simple non-interference theorem about this language:

\begin{theorem}
(Statement of noninterference)
\end{theorem}
\begin{proof}
XXX TODO should be simple
\end{proof}

\subsection{Combination (XXX)}


