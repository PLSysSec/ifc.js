> ----------- REVIEW 1 -----------
> This paper develops a formal framework for extending any sequential
> language with message-passing concurrency primitives, with
> coarse-grained information flow tracking. The technical idea is
> straightforward: Take a sequential language, add concurrent message
> passing primitives whose semantics track coarse taints over processes
> and fine taints over messages. To prevent information leaks, processes
> cannot share memory in the basic system (an extension that removes
> this restriction is informally described in Section 6.1, but that does
> not look satisfactory). The combination is presented using the
> Matthews-Findler approach for combining semantics from POPL'07 but, in
> reality, the paper's work is based on the LIO monad of [51], which
> does a similar combination for Haskell. A similar implementation for
> JavaScript also exists [54]. The overlap is high: The basic work of
> this paper (Section 2) is a (simple) abstract formalization of the
> ideas in [51], [54] and a lot of work in information flow control in
> operating systems, and there is not much novelty in it.
>
> The paper gets interesting in Section 3.2, where it proves that under
> a round-robin scheduler, this method yields termination-sensitive
> non-interference (absence of information flow leaks, when the
> environment can observe termination), but with a sequential scheduler,
> only termination-insensitive noninterference is obtained. This result
> looks very interesting and may be of independent interest, e.g., for
> showing closure for noninterference under parallel program
> composition. Even better, the paper shows (in Theorem 5) that the same
> result holds when operational semantics are restricted in suitable
> ways. In particular, this yields a compositional proof that, if
> messages cannot contain pointers, then there is no need to clone heaps
> for forked processes (Section 4.2). The result is obvious, but the
> compositional proof is elegant.
>
> The main let-down of the paper is that the remaining sections --
> applications to real languages and extensions -- are non-technical and
> preliminary. The application to real languages (Section 5) merely
> recapitulates existing work for Haskell and JavaScript and provides a
> very vague outline for C (based on obvious process confinement using
> OS primitives, or using the hypervisor-mode as in the system Dune). No
> connection to the formalism of the earlier sections is made. Also, can
> you prove noninterference with the rule JS-SEND of Section 5.3?
>
> The extensions section (Sec. 6) looks like a list of speculative ideas
> and does not indicate whether any of the extensions have actually been
> worked out. In particular, the paper suggests that labeled mutable
> references can be handled as in prior work, but this requires a tight
> integration of the semantics of the original language and the IFC
> layer, so I don't see how it aligns with the Matthews-Findler approach
> in the beginning of the paper. The paper also does not cover external
> effects, which are rather essential in practice, specifically for the
> stated motivation of the paper (JavaScript), so it seems that the work
> is incomplete.
>
> In Section 7 (proofs), the authors seem to have renamed theorems. What
> they call theorems 3 and 4 in Section 7 seem to be the two parts of
> theorem 5. (The actual theorems 3 and 4 have trivial proofs.)
>
> Section 8 and parts of Section 9 are disconnected from this paper
> because they seem to be talking of an alternate, monadic presentation
> of the work, which has not been explained at all (actually, given the
> connection to LIO, why not develop the entire formalism with a monad
> in the first place?).
>
> On the whole, I see novel content in Sections 3 and 4 that I like, but
> the rest of the paper looks like a rehash of prior work (Sections 2,
> 4) and preliminary/incomplete (Sections 5, 6, 8). The contributions
> are rather thin, hence my rating of weak reject.
>
> ----------------------- REVIEW 2 ---------------------

> I appreciate the effort the authors are making to give a methodology
> for retrofitting existing languages with information flow control,
> but I don't quite buy the generality of their method. Section 2,
> where a small untyped lambda calculus is retrofitted with IFC, seems
> reasonable, but how does this really scale in practice? Section 5,
> which describes real world examples of this retrofitting, feels like
> it is trying to shoe-horn two previous one-off retrofittings into a
> unified framework. However, the framework didn't come first. In
> fact, the Haskell and JavaScript retrofittings needed to deal with
> some special cases, e.g., XMLHttpRequest, that are not covered by
> the methodology outlined in Section 2. Indeed, the authors state in
> Section 6.4 that external effects are a problem. I am not convinced
> that starting from the methodology outlined in Section 2, one would
> have a clear path to retrofitting some other language with IFC. The
> proofs about the language described in Section 2 just don't say much
> about a real world language.


> Page 10, Proof of Theorem 3... why induct on the length of the
> derivation sequence instead of inducting on the structure of the
> derivation directly?

> ----------------------- REVIEW 3 ---------------------

We agree with reviewer 3's specific questions, below we clairfy some
of the points.

> In section 5.3 JavaScript, why are only strings allowed to be sent across a
> channel? Shouldn't an arbitrary JSON value be safe?

Any structurally cloned objects (and labeled Blobs) can be sent across
a channel, our rule is limited to strings for simplicity.

> Also in section 5.3, there's not much development of SWAPI, and I cannot
> find any further references on the main author's website nor via Google.
> This contributed to me not feeling comfortable with the JavaScript
> implementation.

We didn't realize that our bibtex didn't include a link to the paper:
deian.net/swapi.pdf (We disabled indexing since the paper is under
anonymous submission.)
