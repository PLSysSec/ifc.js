External effects
----------------

# is the system general?
#
# true, we can't handle external effects

The reviewers are concerned that our treatment of external effects makes the
work incomplete. We remark that like other IFC systems, external effects can be
handled by internalizing them (manually) into the IFC language. For instance,
JPMail (a secure mail agent) [1] essentially re-implements the primitives with
external effects in Jif (a compiler for IFC in Java). In addition, Paragon [2]
internalizes external effects by wrapping the corresponding primitives to be
IFC-aware [3]. JSFlow [25] manually wraps JavaScript primitives with external
effects. Similarly, as in the XMLHttpRequest used in SWAPI, our technique
amounts to wrapping the "native" unsafe code. While we can extend the language
with a general external effect primitive (e.g., 'out'), we do not think this add
much value, formally or practically. This is because the treatment of external
effects is very much application specific. For instance, the HTTP client in
SWAPI (XMLHttpRequest) and LIO (as used in Hails [22]) both wrap the native code
to make IFC-aware, but the actual label checks differ simply because of the
different setting and attacker models: browser (client) vs. server.  While
important for pushing IFC into practice, we believe that general treatment of
external effects is an open problem and complementary to this work.

Generality and novelty of the system
------------------------------------

# that doesn't make it not real

A reviewer asked if our system really applies to real-world languages,
pointing to our inability to deal with external effects.  It is true
that our framework assumes that the target language must not have
external effects.  However, this is not an unreasonable constraint: in
Section 6, we discussed how real-world languages can be constrained to
achieve this.  Unfortunately, due to space restrictions, we left the
discussion of the mapping to the formalism as informal discussion.

We do not claim that our work is general enough to handle languages
where effects cannot be tamed (we will emphasize this on revision).
Yet some languages can be tamed (as we discuss) and others don't even
have external effects.  For example, our work is directly applicable
to "vanilla" JS (EcmaScript), which does not have any external effects
-- indeed, under one lens, one can see our work as presenting an
alternative (to [25]) coarse-grained IFC system for JS.  Indeed the
motivation behind this work was to address the question of how to
build an efficient, non-intrusive IFC system for JS.

Similarly, there was a comment that this work simply shoe-horned SWAPI
and LIO into a "unified framework".  While our language uses ideas from
LIO and SWAPI, we note that the current (and at the time of the writing)
versions of these systems are using the concepts of this paper. It is
not the case that "the framework didn't come first". For instance, in
LIO [53] (and Breeze [28]) exceptions were originally treated in a rather
complex fashion; as we discuss in the paper, exceptions are internal
effects and thus the security concern becomes trivial; LIO was modified to
adopt this new approach.

As for the first reviewer's concern that the IFC system presented is
simply a rehash of prior work, we claim the approach of dealing with
internal effects and our asynchronous communication primitives is
novel. To our knowledge this is the first language-based dynamic IFC
system to use such asynchronous primitives and work on both concurrent
and sequential schedulers. (While simple, the checks performed by our
asynchronous communication primitives imply a more flexible
system---synchronous primitives effectively impose that the end-points
have the same label.) Moreover, we believe that our formalization
serves as a stepping stone for formal reasoning about IFC OS work.

Extensions
----------

The reviewers asked if we actually worked out the extensions to
language. We chose to present the core ideas separate from extensions
for simplicity and because the features largely depend on the
embedding. For example, labeled MVars are natural to Haskell, but
not JS. Nevertheless, these extensions have been formalized and are
implemented in LIO and/or SWAPI. (The only extension common
to both system systems are labeled values.) The main points on how
to extend the system with such features follows from the discussion:
they must be added to the IFC language and the no sharing
"sandbox-local pointers" rule (of send) must be used.  For example,
in the labeled references case we amend the IFC language state to
contain a labeled reference store; these labeled references are
distinct from the native references a target language might have and
all access abides by IFC.  (For this reason, there is also no
conflict with the approach of Matthews and Findler as brought up by
the first reviewer.)

Other questions
---------------

As reviewer 3 points out, the reference about SWAPI does not include
an URL.  It is available at http://deian.net/swapi.pdf and currently
not indexed by search engines because the paper is being anonymously
submitted.  We apologize for the mistake.

Reviewer 1 ask why we have not developed our formalism with a monad.
One of our motivations was to formalize an IFC system for JavaScript,
whose semantics are typically not presented in a stratified way by
distinguishing a monadic and a pure fragment.  A non-monadic approach
enables a more natural formalism for a large class of languages,
including JavaScript.

Reviewer 2 ask about the proof strategy for Theorem 3.  Performing
induction on the length of the derivation sequence followed by
induction on the derivation tree is standard for small-step
operational semantics.  This is isomorphic to induction on the
structure of the derivation for ->*.

Reviewer 3 asks about shared mutable references:  It is correct that a
different design choice might allow shared mutable references in this
way.  However, because native references are protected by the current
label, this would effectively be a fine-grained IFC system, requiring
checks for all reference reads and writes.  This would be against our
goal of a coarse-grained system.  We will improve the unfortunate
phrasing.

Reviewer 3 asks about the values sent across channels in SWAPI.  For
simplicity, we require them to be strings in the paper, thought any
structurally cloned object (as well as labeled blobs) are actually
permitted.

Reviewer 1 ask about the soundness of the JS-send rule.  While omitted
in the paper, this rule can be proven to be non-interfering.
Intuitively, for an attacker at level L, the additional premise
evaluates regardless of secrets at a level above L, thus ensuring that
no secrets can be observed.

References
----------

[1] Boniface Hicks, Kiyan Ahmadizadeh, and Patrick McDaniel. Understanding
practical application development in security-typed languages. In 22nd Annual
Computer Security Applications Conference (ACSAC), Miami, Fl, December 2006.

[2] Paragon for Practical Programming with Information-Flow Control Niklas
Broberg, Bart van Delft and David Sands Asian Symposium on Programming Languages
and Systems (APLAS) 2013, Springer

[3] http://www.cse.chalmers.se/research/group/paragon/?p=Case%20Studies 
