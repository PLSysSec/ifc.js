Reviewer 2 asks whether or not our method actually scales in practice,
pointing to our inability to deal with external effects as a mark
against it.  It is true that dealing with external effects is important
for pushing IFC into practice, and our work is not primarily concerned
with addressing this issue.  However, this problem is endemic to all
information flow control systems: for instance, JPMail [1] re-implements
primitives with external effects in Jif; Paragon [2] internalizes
external effects by wrapping the corresponding primitives to be
IFC-aware [3]; JSFlow [25] manually wraps JavaScript primitives with
external effects.  This is not to say that the systems we have
implemented do not deal with external effects: e.g. XMLHttpRequest as
used in SWAPI essential wraps the "native" unsafe code. While we could
have formally modeled these effects with an external effect primitive
(e.g., 'out'), we do not think this add much value, formally or
practically. This is because the treatment of external effects is very
much application specific.

Thus, the generality of our system does not come from a treatment of
external effects; rather, assuming that external effects are taken care
of (Section 6), it comes from our ability to accomodate arbitrarily
complex internal semantics.  For example, our work is directly
applicable to "vanilla" JS (EcmaScript), which does not have any
external effects.  As opposed to existing IFC systems [25] which incur
tremendous overhead, we show that you can build an efficient,
non-intrusive IFC system for JavaScript, or any other language which can
be isolated.

# about shoehorning

Similarly, there was a comment that this work simply shoe-horned SWAPI
and LIO into a "unified framework".  While our language uses ideas from
LIO and SWAPI, we note that the current (and at the time of the writing)
versions of these systems are using the concepts of this paper. It is
not the case that "the framework didn't come first". For instance, in
LIO [53] (and Breeze [28]) exceptions were originally treated in a rather
complex fashion; as we discuss in the paper, exceptions are internal
effects and thus the security concern becomes trivial; LIO was modified to
adopt this new approach.

As for the first reviewer's concern that the IFC system presented is
simply a rehash of prior work, we claim the approach of dealing with
internal effects and our asynchronous communication primitives is
novel. To our knowledge this is the first language-based dynamic IFC
system to use such asynchronous primitives and work on both concurrent
and sequential schedulers. (While simple, the checks performed by our
asynchronous communication primitives imply a more flexible
system---synchronous primitives effectively impose that the end-points
have the same label.) Moreover, we believe that our formalization
serves as a stepping stone for formal reasoning about IFC OS work.

Extensions
----------

Reviewer 1 asks about the extension section, and whether we actually
worked out these ideas or not. We chose to present the core ideas
separately from extensions for simplicity. However, the IFC language
extensions described in Section 6 have been formally worked out, and
are also part of the JavaScript or Haskell implementation, or both.
W.r.t. the comment about labeled references not being amenable to
Matthews-Findler-style semantics, we note that labeled references
are part of the IFC state and are distinct from the native references
a target language might have. For this reason, there is no conflict
with the approach of Matthews and Findler.

Other questions
---------------

As reviewer 3 points out, the reference about SWAPI does not include
an URL.  It is available at http://deian.net/swapi.pdf and currently
not indexed by search engines because the paper is being anonymously
submitted.  We apologize for the mistake.

Reviewer 1 ask why we have not developed our formalism with a monad.
One of our motivations was to formalize an IFC system for JavaScript,
whose semantics are typically not presented in a stratified way by
distinguishing a monadic and a pure fragment.  A non-monadic approach
enables a more natural formalism for a large class of languages,
including JavaScript.

Reviewer 2 ask about the proof strategy for Theorem 3.  Performing
induction on the length of the derivation sequence followed by
induction on the derivation tree is standard for small-step
operational semantics.  This is isomorphic to induction on the
structure of the derivation for ->*.

Reviewer 3 asks about shared mutable references:  It is correct that a
different design choice might allow shared mutable references in this
way.  However, because native references are protected by the current
label, this would effectively be a fine-grained IFC system, requiring
checks for all reference reads and writes.  This would be against our
goal of a coarse-grained system.  We will improve the unfortunate
phrasing.

Reviewer 3 asks about the values sent across channels in SWAPI.  For
simplicity, we require them to be strings in the paper, thought any
structurally cloned object (as well as labeled blobs) are actually
permitted.

Reviewer 1 ask about the soundness of the JS-send rule.  While omitted
in the paper, this rule can be proven to be non-interfering.
Intuitively, for an attacker at level L, the additional premise
evaluates regardless of secrets at a level above L, thus ensuring that
no secrets can be observed.

References
----------

[1] Boniface Hicks, Kiyan Ahmadizadeh, and Patrick McDaniel. Understanding
practical application development in security-typed languages. In 22nd Annual
Computer Security Applications Conference (ACSAC), Miami, Fl, December 2006.

[2] Paragon for Practical Programming with Information-Flow Control Niklas
Broberg, Bart van Delft and David Sands Asian Symposium on Programming Languages
and Systems (APLAS) 2013, Springer

[3] http://www.cse.chalmers.se/research/group/paragon/?p=Case%20Studies 
