\section{Security guarantees}
\label{sec:formal}

In this section we present the formal security guarantees provided by
our embedding.
%
Concretely, we show that an IFC langauge, |specLang alpha (targetLang
nop)|, satisfies non-interference(NI)~\tocite{}.
%
Intuitively, non-interference states that secret values cannot be
leaked by programs written in the language.
%
As we show below, the precise scheduling policy |alpha| dictates
whether or not the guarantee holds for programs with diverging tasks.

We prove non-interference for |specLang alpha (targetLang nop)| using
the \emph{term erasure} technique of~\tocite{}.
%
Intuitively the term erasure technique allows us to show that a an
attacker does not learn any sensitive information from a program
written in a NI language, if the program behaves identically to the
same program with all sensitive data ``erased.''
% 
To accommodate for this, we extend our formalism to account for
programs with erased configurations and a function |erasef l| that
performs erasures, usually by rewriting (parts of) configurations that
are more sensitive than |l| to a new syntactic construct |bullet|.
%
Directly, we can now give a precise definition for the kinds of
languages we wish to prove NI.

\begin{definition}[Information-flow control language]
    An information-flow control language |L| is a tuple |(C, .->,
    erasef l)|, where $c \in |C|$ is the type of machine configurations, |.->| is a
    reduction relation between machine configurations and |erasef l : C -> tyerase C|
    is an erasure function parametrized on labels from machine configurations to \emph{erased} machine
    configurations |tyerase C|.  For sequential languages, the
    language is augmented with a set of terminal configuration states $V
    \subseteq |C|$ for which there are no possible further transitions.
\end{definition}

%{
%format .->  = "\overset{\alpha}{\hookrightarrow}"
Using this definition, |specLang alpha (targetLang nop) = (ifc C, ifc
V, .->, erasef il)|, such that $|ifc C| = |iS| \times \prod |it|$ and
$|ifc V| = |iS| \times |it|^*$, where $|it|^* \subset |it|$ it the
type for tasks whose expressions have been reduced to
values.\footnote{
  Here, we abuse notation by describing types for configuration parts using the
  same metavariables as the ``instance'' of the type, e.g., |it| for the type of
  task.
}
The erased configuration |tyerase (ifc C)| extends |ifc C| with configurations
containing |bullet|; Figure~\ref{fig:erasure} gives the precise definition for
our erasure function.
%
A task and its corresponding message queue is completely removed from the task
list if its label does not flow to the attacker observation level |il|;
otherwise, we apply the erasure function homomorphically and remove any message
from the task's message queue that are more sensitive than |il|.
%}

\begin{figure} % fig:erasure
\begin{align*}
  &|erase il (iconf iS its) =
  iconf (erase il iS) (fltr (\ it . it = bullet) (map (erasef il) its))|\\
  &|fullconf id il' tS ie| \begin{cases}
    |bullet| & |il' cantFlowTo il| \\
    |fullconf id il' (erase l tS) (erase l ie)| & \text{otherwise}
  \end{cases} \\
  &|erase il emptyset = emptyset|\\
  &|erase il (iS [id mapsto Q]) =| \begin{cases}
    |erase il iS| & \text{|il' cantFlowTo il|, where |il'| is}\\
    & \text{the label of thread |id|} \\
    |(erase il iS) [id mapsto (erase il Q)]| & \text{otherwise}
  \end{cases} \\
  &|erase il Q = filter il Q|\\
  &|erase il v = v|
\end{align*}
\caption{ Erasure function for tasks, queue maps, message queues, and
configurations.  In all other cases, including target-language constructs,
|erasef il| is applied homomorphically.  \label{fig:erasure} }
\end{figure}

We note that the definition of |erasef il| precisely captures the IFC
language's attacker model. 
%
For instance, in our case, by removing sensitive tasks and messages from the
system, we assume that that the attacker cannot observe the number of sensitive
tasks or messages.
%
While such assumptions are standard~\tocite{}, our definitions allow for
stronger attackers that may be able to inspect resource usage.\footnote{
  We believe that we can extend |specLang alpha (targetLang nop)| to
  such models using the resource limits techniques of~\tocite{}.
  %
  We leave this extension to future work.
}

Non-interference relies on the definition of an attacker's observational power at
security level |l|, which is typically defined as an equivalence
relation---called |l|-equivalence---on configurations, i.e., an attacker cannot
distinguish two configurations that are |l|-equivalent.
%
Since our erasure function captures the attacker model, we simply define this
equivalence as the syntactic-equivalence of erased configurations.
%
\begin{definition}[|l|-equivalence]
    In a language |(C, .->, erasef l)|, two machine configurations
    |memberf (c, c') C| are considered $l$-equivalent (|c ~= c'|)
    if |erase l c = erase l c'|.
\end{definition}
%

Intuitively, we can now state that a language satisfies non-interference if an
attacker at level |l| cannot distinguish the runs of any two |l|-equivalent
configurations.
%
This precise NI property is called termination sensitive non-interference
(TSNI), since it considers runs of programs, and thus does not allow for leaks
due termination or internal timing behavior.
%
Formally, we define TSNI as follows.

\begin{definition}[Termination Sensitive Non-Interference (TSNI)]
  A language |(C, .->, erasef l)| is termination
  sensitive non-interfering if for any label |l|, and configurations
  |c1, c1', c2 member C|, if
  \begin{equation} \label{eq:tsni-lhs}
    |c1| \approx_{|l|} |c2|
    \qquad \text{and} \qquad
    |c1| |.->|^* |c1'|
  \end{equation}
  then there exists a configuration |c2' member C| such that
  \begin{equation} \label{eq:tsni-rhs}
    |c1'| \approx_{|l|} |c2'|
     \qquad \text{and} \qquad
    |c2| |.->|^* |c2'|
    \ \text{.}
  \end{equation}
\end{definition}
%
In other words if we take two |l|-equivalent configurations, then for every
intermediate step taken by the first configuration, there is a corresponding
number of steps that the second configuration can take to result in a
configuration that is |l|-equivalent to the first resultant configuration.
\Red{TODO: Do we want a commutative diagram to illustrate this?}

\begin{figure}
  Round robin:
\begin{code}
  roundrobin step (it1, it2, ldots)  = it2, ldots, it1
  roundrobin N (it1, it2, ldots)     = it2, ldots
  roundrobin F (it1, it2, ldots)     = it2, ldots, it1
\end{code}
  Sequential:
\begin{code}
  seq step (it1, it2, ldots)     = it1, it2, ldots
  seq N (it1, it2, ldots)        = it1, it2, ldots
  seq N (it)                     = it
  seq F (it1, it2, ldots, itn)   = itn, it1, it2, ldots
\end{code}
\caption{Round robin and sequential scheduling policies.\label{fig:scheduler}}
\end{figure}

Directly, we now show that our IFC language satisfies TSNI under a particular
scheduling policy.
%
Specifically, we consider the language under the round-robin scheduler
|roundrobinf| given in Figure~\ref{fig:scheduler}.

\begin{theorem}[Concurrent specification language is TSNI].
  \label{thm:rr-tsni}
For any target language |targetLang nop|, |specLang roundrobinf
(targetLang nop)| satisfies TSNI.
\end{theorem}

In general TSNI will not hold for an arbitrary scheduler |alpha|.
%
For example, |specLang alpha (targetLang nop)| with a scheduler that inspects a
sensitive threads current state when deciding which thread to schedule next
will clearly not satisfy TSNI.
%
In Section~\toref{} we detail the preceise scheduler for which our
specification language is TSNI.
%
Here, we simply remark that even non-adversairal schedulers are not always safe.

Consider, for example, the sequential scheduling policy |seqf| given in
Figure~\ref{fig:scheduler}.
%
It is trivial to show that |specLang seqf (targetLang nop)| does not satisfy
TSNI.
%
Concretely, consider a target language similar to |targetLang ML| with an
additional expression terminal |diverge| that denotes a divergent computation,
i.e., |diverge| always reduces to |diverge| and a a simple label lattice |{pub,
sec}| such that |pub canFlowTo sec|, but |sec cantFlowTo pub|, we can write the
following program in the specification language:
\begin{code}
ic1 = iS ; fullconf 1 sec tS1 (IT(when false diverge)),  fullconf 2 pub tS1 ie
ic2 = iS ; fullconf 1 sec tS1 (IT(when true diverge)),   fullconf 2 pub tS2 ie
\end{code}
These two configurations are |pub|-equivalent, however |ic1| will reduce (in two
steps) to |ic1 = iS ; fullconf 2 pub tS1 (IT diverge)|, whereas |ic2| will not make
any progress.
%
Suppose that |ie| is a computation that writes to a |pub| channel,\footnote{
Though we do not model labeled channels, extending the calculus with such a
feature is straight forward, see Setion~\ref{}.
} then the |sec| thread's decision to diverge or not is directly leaked to a
public entitiy.

In certain cases, however, a TSNI-safe concurrent scheduling policy such as
|roundrobinf| cannot be considered without imposig a non-trivial burden on the
concrete implementation.
%
(Section~\ref{ref:real} describes a particular embedding with JavsScript as the
target language.)
%
Hence, we consider an alternative NI property---called termination insensitive
non-interference---that can also be upheld by sequential languages at the cost
of leaking one bit through (non)-termination.
%
\begin{definition}[Termination Insensitive Non-Interference (TINI)]
  A language |(C, V, .->, erasef l)| is termination
  insensitive non-interfering if for any label |l|, and configurations
  |c1, c2 member C| and |c1', c2' member V| if
   $|c1| \approx_{|l|} |c2|$,
   $|c1| |.->|^* |c1'|$, and
   $|c2| |.->|^* |c2'|$, then
   $|c1'| \approx_{|l|} |c2'|$.
\end{definition}

TSNI states that if we take two |l|-equivalent configurations, and both
configurations reduce to terminal configuration states (for which there are no
possible further transitions), then the end configurations are also
|l|-equivalent.
%
We highlight that this statement is much weaker than TSNI: it only states that
terminating programs do not leak sensitive data.
 
Nevertheless, we believe TINI to be a useful for many scenariors and thus we
show that our IFC language with the sequential scheduling policy |seqf|
satisfies TINI.
%
\begin{theorem}[Sequential specification language is TINI]
For any target language |targetLang nop|, |specLang seqf (targetLang
nop)| satisfies TINI.
\end{theorem}
