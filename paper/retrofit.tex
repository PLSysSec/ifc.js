\section{Retrofitting Languages with IFC}
\label{sec:retrofit}

Information flow control systems operate by associating data with \emph{labels},
and specifying whether or not data tagged with one label |l1| can flow
to another
label |l2| (written as |canFlowTo2 l1 l2|).  These labels encode the desired
security policy (for example, confidential information should not flow to
a public channel), and the work of specifying the semantics of an information
flow language involves demonstrating that impermissible flows cannot happen,
a property called \emph{non-interference}.

Supporting fine-grained labeling of data in a programming language often
requires extremely intrusive modifications to its semantics and
implementation.  In this paper, we advocate applying coarse-grained
labeling~\cite{Zeldovich:2006, lio} at its most extreme: our starting point
is multiple instances of completely isolated language runtimes or \emph{tasks}, with
information flow control applied between their communication.  For
languages which are implemented with isolation, such as JavaScript or C
with access to hardware privilege separation, systems along these lines
are far more easily implementable and require fewer semantic changes.

What distinguishes this setting from previous coarse-grained IFC
systems?
%
First, even though the underlying semantic model involves communicating
tasks, these tasks can be coordinated together in ways that simulate
traditional features in monolithic languages.  In fact, simulating
features in this way is a very useful \emph{design tool} for discovering
what variants of the features are permissible and which are not.
%
Second, although completely separate tasks are semantically easy to
reason about, real-world implementations often blur the lines between
tasks in the name of efficiency (Section~\ref{sec:concrete}).
Characterizing what optimizations are permissible is subtle, since
removing transitions from the operational semantics of a language can
break non-interference.

To give a simple example, here is a low security task sending a high security
task a mutable reference:
\begin{align*}
    & |let i = TI (sandbox (brecvf x _ (IT (!(TI x)))))|\\
    & |in TI (send (IT i) l (IT (ref true)))|
\end{align*}
For now, ignore the tags |TI| and |IT|: roughly, this code creates a new
|sandbox|ed task with identifier $i$ which waits (\textbf{blockingRecv}) for a
message, and then \textbf{send}s the task a mutable reference |(ref
true)| which is labeled $l$.  If this operation actually shared the mutable cell, this cell
could be used to violate information flow control, by leaking
information from the high security task to the low security task.

This example demonstrates both of our design principles.  When working
with isolated tasks, each of which have their own heaps, the isolation
is obviously true: the sandboxed task receives a dangling pointer.  From
there, we can further ask: given the obviously safe formulation with
separate heaps, can this fact be useful for showing the safety of a
semantics which only has a single heap (we answer this question
positively in Section~\ref{sec:single-heap})?  Finally, this na\"ive
semantics violates expectations about how inter-task communication works
on a shared heap, and strongly suggests one should restrict the types of
data which may be passed between tasks (for example, in JavaScript, one
might only allow JSON objects to be passed between tasks, rather than
general object structures).

Before moving on to the formal treatment of our system, we'd like to give
two more examples of language features which have an interesting interpretation
when viewed in the setting of multiple tasks.

\paragraph{Stack frames versus scheduling}  One feature which is
supported by some information flow control systems is the ability to
temporarily raise the current label in order to do computation on data
(as done by LIO's |toLabeled| and Breeze's
brackets~\cite{Hritcu:2013:YIB:2497621.2498098,
stefan:2012:arxiv-flexible}).  After the computation, the label is lowered back to the original label,
enforcing a stack discipline.  This is the trickiest part of the feature: care must be taken to ensure that information doesn't leak when
the label is lowered. In fact, systems with this feature generally only
achieve termination-insensitive non-interference: if the high secrecy
section doesn't terminate, this is observable by the non-execution of
the defunct public continuation.

\begin{figure}
\begin{align*}
    & |toLabeled l te @= | \\
    & |tab let i = taskId in| \\
%%    & |tab let j = TI (sandbox (IT (TI (setLabel l); TI (send i l (IT te)))))| \\
    & |tab let j = TI (sandbox (IT (TI (send i l (IT te)))))| \\
    & |tab in (\ _ . TI (setLabel l); TI (recvf x _ x unit))|
\end{align*}
\caption{Encoding of toLabeled using isolated tasks.}\label{fig:toLabeled}
\end{figure}


When considering tasks, we will instead say that the allocation of a new
stack frame with a raised label corresponds to the creation of a new
isolated task; a sample encoding using our language is shown in
Figure~\ref{fig:toLabeled}.
However, this is not enough: in a stack discipline, one generally
expects stack entries to be processed in order, rather than in parallel
as would be suggested by isolated tasks.  The sequential processing of
the task queue corresponds to a specific \emph{scheduling policy} of
these tasks.  The recasting of the problem to one of scheduling
highlights the essential difference between termination-insensitive and
termination-sensitive non-interference, and we will show how different
scheduling policies give different security guarantees.

\paragraph{Exceptions versus message passing}
Another language feature that has caused difficulty for
many information flow control systems is exceptions handling,
when built on top of this stack discipline.
%
The key difficulty appears when considering the propagation of exceptions
across stack boundaries where the current label is restored.
%
If the exception crosses this boundary, it can leak information about the
inner secret computation into a public computation; hence, one must
explicitly ensure that |toLabeled| does not propagate exceptions.

When stack frames are treated as isolated tasks, the correct semantics
are achieved automatically.
%
Exceptions simply stop when the hit the top-level of a task:
the only way for the frame to communicate information is by
initiating inter-task message passing.
%
For instance, 
\begin{code}
TI(toLabeled l (IT (if te then fail else true))); true
\end{code}
always evaluates to |true|, regardless of the value of |te|.
\Red{TODO: note that if the target language allows inspecting if
  result is exception we can implement Breeze's NAV (vs. just
propagating)}

\subsection{Preliminaries}

Our goal now is to
describe how to take a \textbf{{\color{red} target
language}} with a formal operational semantics and combine it with an
\textit{{\color{blue} information flow control language}}.  For example,
taking ECMAScript as the target language and combining it with our IFC
language should produce the formal semantics for SWAPI.  In this
presentation, we use a simple, untyped lambda calculus with mutable
references and fixpoint in place of ECMAScript, to demonstrate some of the key
properties without having too much detail (and because the embedding really
doesn't care about what, exactly, is in the target language); we discuss the proper
embedding in more detail in Section~\ref{sec:real}.

\paragraph{Notation}
We have typeset nonterminals of the target language using \textbf{{\color{red}
bold font}} while the nonterminals of the IFC language have been typeset
with \textit{{\color{blue} italic font}}.  Readers are encouraged to view
a color copy of this paper, where target language nonterminals are colored \textbf{{\color{red} red}}
while IFC language nonterminals are colored \textit{{\color{blue} blue}}.

\subsection{Target Language: Mini-ES}

In Figure~\ref{fig:ml}, we give a simple, untyped lambda calculus with
mutable references and fixpoint, prepared for combination with an
information flow control language.  The presentation is mostly standard, and utilizes Felleisen-Hieb reduction
semantics~\cite{Felleisen:1992:RRS:136293.136297} to define the
operational semantics of the system.  One peculiarity is that our language
defines an evaluation context |tE|, but, the evaluation rules have been
expressed in terms of a different evaluation context |curlyRedE|;
Here, we follow the approach of Matthews and
Findler~\cite{Matthews:2007:OSM:1190216.1190220} in order to simplify combining
semantics of multiple languages. 
To derive the usual operational semantics for this language, the evaluation
context merely needs to be defined as |conf tS te @= tS, bracket tE te|.
However, when we combine this language with an IFC language, we
reinterpret the meaning of this evaluation context.

In general, we require that a target language be expressed in terms
of some global machine state |tS|, some evaluation context |tE|,
some expressions |te|, some set of values |tv| and a \emph{deterministic}
reduction relation on full configurations $|tS| \times |tE| \times |te|$.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
te   ::= tv | tx | te te | if te then te else te
       | ref te | !te | te := te | fix te
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE | fix tE

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\begin{mathpar}

\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{ | fresh ta | }
{| conf tS (ref tv) -> conf (bracket tS (mapsto ta tv)) ta |}

\and
\inferrule[T-deref]
{ |memberf ((ta, tv)) tS| }
{| conf tS (!ta) -> conf tS (tv) |}

\and
\inferrule[T-ass]
{ }
{| conf tS (ta := tv) -> conf (bracket tS (mapsto ta tv)) tv |}

\and
\inferrule[T-fix]
{ }
{| conf tS (fix (\ x . e)) -> conf tS ({fix (\ x . e)/x} e) |}

%\and
%\inferrule[T-fail]
%{ }
%{| conf tS ( tE [ fail ] ) -> conf tS fail |}
\end{mathpar}

\caption{|targetLangML|: simple untyped lambda calculus extended with booleans,
mutable references and general recursion. |FV(te)| returns the set of free
variables in expression |te|.}
\label{fig:ml}
\end{figure}

\subsection{IFC Language}

As mentioned previously, most modern, dynamic information flow control
languages encode policy by associating a label with data.  Our
embedding is agnostic to the choice of labeling scheme; we only require
the labels to form a lattice~\cite{Denning:1976:LMS:360051.360056} with
the partial order $\sqsubseteq$, join |lub|, and meet |glb|.  In this
paper, we simply represent labels with the metavariable $l$, but do not
discuss them in more detail.

In our coarse-grained floating-label approach, labels are associated with tasks.
%
The task label---we refer to the label of the currently executing task as the
\emph{current label}---serves to protect everything in the task's scope;
all data in a task shares this common label.
%
Hence before performing a read or a write, the IFC monitor inspects the
current label to decide whether the operation is permitted.
%
A task can only write to entities that are at least as sensitive.
%
Similarly, it can only read from entities that are less sensitive.
%
However, as in other floating-label systems, this current label can be raised
to allow the task to read from more sensitive entities at the cost of giving up
the ability to write to certain entities.

In Figure~\ref{fig:ifc}, we give the syntax and \emph{single-task}
evaluation rules for a minimal information-flow control language.  
Ordinarily, information flow control languages are defined by directly
stating a base language plus information flow control operators.  In
contrast, our language is purposely minimal: it does not have sequencing
operations, control flow, or other constructs.  However, it contains
support for the following core information flow control features:

\begin{itemize}
    \item First-class labels, with label values $l$ as well as operations for computing on
labels (|canFlowTo|, |lub| and |glb|).
    \item Operations for inspecting (\textbf{getLabel}) and modifying
    (\textbf{setLabel}) the current label of the task (a task can only increase its label).
    \item Operations for non-blocking inter-task communication (\textbf{send}
    and \textbf{recv}), which interact with the global store of per-task
    message queues |iS|.
%%     Labels are associated with message at the time of
%%     the send; the label on a message must always be at least as sensitive as that
%%     of the sending thread, since, conceptually, once a message is put on a
%%     message queue it is no longer protected by the current label, rather it is
%%     protected by the message label.
%%     Dually, when reading a message with |recv| the current label of the
%%     receiver must be at least as high as the message label.
    \item A sandboxing operation used to spawn new isolated tasks. In
    concurrent settings |fork| corresponds to a fork-like primitive,
    whereas in a
    sequential setting, it more closely resembles the LIO
    |toLabeled|~\cite{lio} and Breeze
    bracket~\cite{Hritcu:2013:YIB:2497621.2498098} constructs.
\end{itemize}

These operations are all defined with respect to an evaluation context
|curlyBlueE| that represents the context of the current task which, by
conventions is running. The evaluation context has three important pieces of
state: the global message queues |iS|, the current label |il| and the task ID |id|.
 
We note that first class labels, tasks (albeit named differently), and
operations for inspecting the current label are are essentially universal to
all floating-label systems.
%
However, our choice of communication primitives is motivated by
those present in browsers, namely \texttt{postMessage}~\cite{webmessaging}.
%
Of course, other choices, such as blocking communication or labeled channels,
are possible (see Section~\ref{sec:extensions}).
%

These asynchronous communication primitives are worth further
discussion.  When a task is sending a message using |send|, it also labels that
message with a label |il'| (which must be above the tasks current label |il|).
Messages can only be received by a task if its current label is
at least as high as the label of the message.
Specifically, receiving a message using
\[ |recvf ix1 ix2 ie1 ie2| \]
binds the message and the senders task identifier
to local variables |ix1| and |ix2|, respectively, and then executes |ie1|.
Otherwise the message gets removed from the queue by rule \textsc{I-noRecv},
and that tasks continues its execution with |ie2|.
We denote the filtering of the message queue by |filter il Q|,
which is defined as follows.
If |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|, and otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]
This ensures that tasks cannot receive messages that are more sensitive
than their current label would allow.

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie | getTaskId
       |  sandbox ie | send ie ie ie | recvf ix ix ie ie
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE
       |  send iE ie ie | send iv iE ie | send iv iv iE
io   ::=  (il, id ie)
Q    ::=  nil | io , Q
iS   ::=  emptyset | bracket iS (mapsto id Q)
\end{code}

\begin{mathpar}

\inferrule[I-getTaskId]
{ }
{|
niconf iS id il getTaskId
->
niconf iS id il id
|}

\and
\inferrule[I-getLabel]
{ }
{|
niconf iS id il getLabel
->
niconf iS id il il
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
niconf iS id il (setLabel il')
->
niconf iS id il' unit
|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|readState iS (id') = Q|\\
|iS' = bracket iS (mapsto id' (il', id,  iv) , Q)|
}
{|
niconf iS  id il (send id' il' iv)
->
niconf iS' id il unit
|}

\and
\inferrule[I-recv]
{
| (filter il (readState iS id)) = io1 , ... , iok , (il', id', iv)|\\
| iS' = bracket iS (mapsto id (io1 , ... , iok))|\\
}
{|
niconf iS  id il (recvf ix1 ix2 ie1 ie2)
->
niconf iS' id il ({iv/ix1,id'/ix2} ie1)
|}

\and
\inferrule[I-noRecv]
{
| filter il (readState iS (id)) = nil|\\
| iS' = bracket iS (mapsto id nil)|
}
{|
niconf iS  id il (recvf ix1 ix2 ie1 ie2)
->
niconf iS' id il ie2
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |niconf iS id il (il1 lop il2) -> niconf iS id il iv| }
\end{mathpar}
\caption{IFC language with all single-task operations.}
\label{fig:ifc}
\end{figure}

\subsection{The Embedding}
Figure~\ref{fig:embedding}
provides all of the rules responsible for actually carrying out the embedding of the IFC language with the target language.
The most important feature of this embedding is that every task maintains its own
copy of the target language global state and evaluation context, thus
enforcing isolation between various tasks.  In more detail:

\begin{figure}
%{
%format .->  = "\overset{\alpha}{\hookrightarrow}"
%format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
\begin{tabular}{ll}
\begin{minipage}{.22\textwidth}
\begin{code}
iv  ::= cdots | IT tv
ie  ::= cdots | IT te
iE  ::= cdots | IT tE
\end{code}
\end{minipage} &
\begin{minipage}{.22\textwidth}
\begin{code}
tv  ::= cdots | TI iv
te  ::= cdots | TI ie
tE  ::= cdots | TI iE
\end{code}
\end{minipage}
\end{tabular}

\begin{code}
conf tS te @= iconf iS (fullconf id il tS (iniEt te), ldots)
niconf iS id il ie @= iconf iS (fullconf id il tS (iniEi ie), ldots)
CE[e] -> iconf iS (it, ldots) @= CE[e] .-> iconf iS (sched step (it, ldots))
\end{code}

\begin{mathpar}
\inferrule[I-sandbox]
{ 
|iS' = bracket iS (mapsto id' nil)|\\
|tS' = klone(tS)|\\
|it1 = fullconf id il tS (iniE id')|\\
|itnew = fullconf id' il tS' ie|\\
|fresh id'|
}
{|
iconf iS (fullconf id il tS (iniEi (sandbox ie)), ldots)
.->
iS'; sched box (it1, ldots, itnew)
|}

\and
\inferrule[I-done]
{|
|}
{|
iconf iS (fullconf id il tS iv, ldots)
.->
iS ; sched done (fullconf id il tS iv, ldots)
|}

\and
\inferrule[I-noStep]
{|
iconf iS (it, ldots) .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched nostep (it, ldots)
|}

\and
\inferrule[I-border]
{ }
{|
niconf iS id il (IT (TI (ie)))
->
niconf iS id il ie
|}

\and
\inferrule[T-border]
{ } {| conf tS (TI (IT (te))) -> conf tS te|}
\end{mathpar}
\caption{The embedding |specLang alpha (targetLang nop)|, where
|targetLang nop = (tS, tE, te, tv, ->)|}
\label{fig:embedding}
%}
\end{figure}

\begin{itemize}
    \item We extend the values, expressions and evaluation contexts of
      both languages to allow for embeddings terms in one language to
      be embedded in the other, as
      in~\cite{Matthews:2007:OSM:1190216.1190220}.
    %
In the target language, an IFC expression appears as |TI ie| (``target-outside,
IFC-inside''); in the IFC language, a target language expression appears as |IT
te| ( ``IFC-outside, target-inside'').
    \item We reinterpret |CE| to be evaluation contexts on task lists, providing definitions for |curlyRedE| and |curlyBlueE|.  These rules only operate on the first task in the task list, which by convention is the only task executing.
    \item We reinterpret |->|, an operation on a single task, in terms of |.->|, operation on task lists.  The correspondence is simple: a task executes a step and then is rescheduled in the task list according to schedule policy |alpha|.
    Figure~\ref{fig:scheduler} defines two concrete schedulers.
    \item Finally, we define some rules for scheduling, handling sandboxing tasks (which interact with the state of the target language),
    and intermediating between the borders of the two languages.
\end{itemize}

\begin{figure}
  Concurrent, round robin:
\begin{code}
  roundrobin step (it1, it2, ldots)    = it2, ldots, it1
  roundrobin done (it1, it2, ldots)    = it2, ldots
  roundrobin nostep (it1, it2, ldots)  = it2, ldots
  roundrobin box (it1, it2, ldots)     = it2, ldots, it1
\end{code}
  Sequential:
\begin{code}
  seq step (it1, it2, ldots)      = it1, it2, ldots
  seq nostep (it1, it2, ldots)    = it1, it2, ldots
  seq done (it)                   = it
  seq done (it1, it2, ldots)      = it2, ldots
  seq box (it1, it2, ldots, itn)  = itn, it1, it2, ldots
\end{code}
\caption{Scheduling policies}
\label{fig:scheduler}
\end{figure}

The \textsc{I-sandbox} rule is used to create a new isolated task that
executes separately from the existing tasks (and can be communicated
with via |send| and |recv|).  When the new task is created, there
is the question of what the target language state of the new task should
be.  Our rule is stated generically in terms of a function |klone|.
Conservatively, |klone| may be simply thought of as the identity
function, in which
case the semantics of sandbox are such that the state of the target language is \emph{cloned}
when sandboxing occurs.  However, this is not necessary: it is also valid for |klone|
to remove entries from the state.  In Section~\ref{sec:concrete}, we give a more detailed
discussion of the implications of the choice of |klone|, but all our
security claims will hold regardless of the choice of |klone|.

The rule \textsc{I-noStep} says something about configurations for which
it is not possible to take a transition.  The notation
$|ic|\not\overset{\alpha}{\hookrightarrow}$ in the premise
is meant to be understood as
follows:  If the configuration |ic| cannot take a step by any rule other
than \textsc{I-noStep}, then \textsc{I-noStep} applies and the
stuck task gets removed.

Rules \textsc{I-done} and \textsc{I-noStep} define the behavior of the system
when the current thread has reduced to a value, or gotten stuck, respectively.
%
While these definitions simply rely on the underlying scheduling policy,
|alpha|, to modify the task list, as we describe in Sections~\ref{sec:formal}
and~\ref{sec:extensions}, these rules (notably, \textsc{I-noStep}) are crucial
to proving our security guarantees.
%
For instance, it is unsafe for the whole system to get stuck if a particular
task gets stuck, since a sensitive thread may then leverage this to leak
information through the termination channel.
%
Instead, as our example round-robin (|roundrobinf|) scheduler shows,
such tasks should simply be removed from the task list.

%
As in~\cite{Matthews:2007:OSM:1190216.1190220}, rules \textsc{T-border} and
\textsc{I-border} define the syntactic boundaries between the IFC and target
languages.
%
Intuitively, the boundaries respectively correspond to an upcall into and
downcall from the IFC runtime.
%
As an example, taking |targetLangML| as the target language, we can now define a
blocking receive (inefficiently) in terms of the asynchronous |recv| as series
of cross-language calls:
\begin{code}
  brecvf ix1 ix2 ie @=
  tab tab tab (IT (fix (\ k . TI (recvf ix1 ix2 ie (IT k)) )))
\end{code}

We note that our embedding corresponds to the lump embedding
of~\cite{Matthews:2007:OSM:1190216.1190220} where terms in one language are
treated opaquely in the other.
%
Indeed since our embedding is defined for an arbitrary language |targetLang|,
we cannot do better.
%
However, when we have more information about the target language, it is
possible to add rules for a natural embedding of expressions that occur in both
languages.  In our specific example with |targetLangML|, we can choose to
preserve booleans across language boundaries as follows:
\begin{mathpar}
\inferrule
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}

For any target language |targetLang| and scheduling policy |alpha|, this
embedding defines an IFC language, which we will
refer to as |specLang alpha targetLang|.
