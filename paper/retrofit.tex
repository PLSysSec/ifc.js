\section{Retrofitting languages with IFC}
\label{sec:retrofit}

While we would like to add information flow control to \emph{any}
language, we will have to make some assumptions about the form of the
target language.  We consider languages whose semantics can be expressed
in the form of abstract machines |(tS, tE, te, tv, ->)|, where |tS| is the
global machine state, |tE| is an evaluation context, |te| is an
expression in the language, |tv| is the set of values, and |->| is the reduction relation on such
configuration, i.e., $|->| : (|tS| \times |tE| \times |te|)
\rightharpoonup (|tS| \times |tE| \times |te|)$.  Metavariables in this
target language have been colored red.

In Figure~\ref{fig:ml}, we give an example of a standard ML-like
language with mutable references.  These semantics have been prepared
for interoperability in the style of Matthews and Findler~\Red{XXX}; in
particular, the evaluation rules have been expressed in terms of an
evaluation context $\mathcal{E}_{\tar{\Sigma}}$.  Without the embedding,
this evaluation context is defined as |conf tS te @= tS, tE[ te ]|, but
when we perform the embedding, we will reinterpret the meaning
of this evaluation context, lifting these semantics to an IFC setting.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
tty   ::= bool | tty -> tty | ref tty
te   ::= tv | tx | te te | if te then te else te | ref te | !te | te := te
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE 

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\Red{Suggestion: Only give the rules for references, because otherwise this is all standard.}

\begin{mathpar}

\and
\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{| tS' = tS [ ta mapsto tv ] | } 
{| conf tS (ref tv) -> conf tS' ta |}
{| fresh (ta) |}

\and
\inferrule[T-deref]
{| tv = tS(ta) |}
{| conf tS (!ta) -> conf tS tv |}

\and
\inferrule[T-ass]
{| tS' = tS [ ta mapsto tv ] |} 
{| conf tS (ta := tv) -> conf tS' tv |}
\end{mathpar}

\caption{Simple ML-like language}
\label{fig:ml}
\end{figure}

%   \begin{figure}
%   Typing judgment: $|tyrule tG tS te tty|$
%   \begin{mathpar}
%   \inferrule[T-ty-address]
%   {}
%   {| tyrule tG tS a (ref (tyLookup tS a)) |}
%   \end{mathpar}

%   \caption{Selected typing rules for ML-like language}
%   \label{fig:ml-typing}
%   \end{figure}

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie
       |  fork ie | send ie ie ie | ix1, ix2 <= recv. ie ie
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | fork iE 
       |  send iE ie ie | send iv iE ie | send iv iv iE
       |  ix1, ix2 <= recv. ie ie
io   ::=  (il, id ie)
Q    ::=  nil | io , Q

CE[e] -> iconf iS (it, ldots) @= CE[e] .-> iconf iS (sched step (it, ldots))
\end{code}

\begin{mathpar}
%   \and
%   \inferrule[I-done]
%   {|
%   |}
%   {|
%   iconf iS (fullconf id il tS iv, ldots)
%   .->
%   iS ; sched done (fullconf id il tS iv, ldots)
%   |}

\and
\inferrule[I-noStep]
{|
iconf iS (it, ldots) .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched noStep (it, ldots)
|}

\and
\inferrule[I-getLabel]
{ }
{|
niconf iS id il getLabel
->
niconf iS id il il
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
niconf iS id il (setLabel il')
->
niconf iS id il' unit
|}
%{|fresh (id')|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
}
{|
niconf iS  id il (send id' il' ie)
->
niconf iS' id il unit
|}

\and
\inferrule[I-recv]
{
| filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
| iS' = iS[id mapsto io1 , ... , iok]|\\
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ({ie'/ix1,id'/ix2} ie1)
|}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = iS[id mapsto nil]|
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ie2
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |niconf iS id il (il1 lop il2) -> niconf iS id il iv| }
\end{mathpar}
\caption{IFC language}
\label{fig:ifc}
\end{figure}

\begin{figure}
\begin{tabular}{ll}
\begin{minipage}{.22\textwidth}
\begin{code}
iv ::= cdots | IT tv
ie ::= cdots | IT te
iE ::= cdots | IT tE
\end{code}
\end{minipage} &
\begin{minipage}{.22\textwidth}
\begin{code}
tv ::= cdots | TI iv
te  ::=  cdots | TI ie
tE   ::=  cdots | TI iE
\end{code}
\end{minipage}
\end{tabular}

\begin{code}
ix1, ix2 <= brecv . ie @= IT (let tx = TI (ix1, ix2 <= recv. ie  (IT tx)) in tx)

conf tS te @= iconf iS (fullconf id il tS (iniEt te), ldots)
niconf iS id il ie @= iconf iS (fullconf id il tS (iniEi ie), ldots)
\end{code}

\begin{mathpar}
\and
\inferrule[I-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|tS' = klone(tS)|\\
|it1 = fullconf id il tS (iniE id')|\\
|itnew = fullconf id' il tS' (TI ie)|\\
|fresh (id')|
}
{|
iconf iS (fullconf id il tS (iniEi (fork ie)), ldots)
.->
iS'; sched fork (it1, ldots, itnew)
|}

\and
\inferrule[I-border]
{ }
{|
niconf iS id il (IT (TI (ie)))
->
niconf iS id il ie
|}

\and
\inferrule[T-border]
{ } {| conf tS (TI (IT (te))) -> conf tS te|}
\end{mathpar}
\caption{The embedding}
\label{fig:embedding-grammar}
\end{figure}

\begin{figure}
\begin{align*}
  &|erase il (iconf iS its) =
  iconf (erase il iS) (fltr (\ it . it = bullet) (map (erasef il) its))| \\
  &|erase il (tconf id il' ie) =| \begin{cases}
    %|lconf bullet bullet bullet bullet| & |il' cantFlowTo il| \\
    |bullet| & |il' cantFlowTo il| \\
    |fullconf id il' (erase il tS) (erase il ie)| & \text{otherwise}
  \end{cases} \\
  %&|erase il iS [i mapsto Q] = iS [i mapsto (erase il Q)]|\\
  &|erase il Q = filter il Q|\\
  &|erase il (send id il' ie) =| \begin{cases}
    |send id il' bullet| & |il' cantFlowTo il| \\
    |send id il' (erase il ie)| & \text{otherwise}
  \end{cases} \\
  &\text{In all other cases, |erasef il| is applied homomorphically.}
\end{align*}
\caption{Erasure function.}
\end{figure}

The filter function |filter il Q| removes message whose labels do not
flow to |il|. Specifically, if |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|; otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]


In the case of extending
\begin{mathpar}
\inferrule[I-bool]
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule[T-bool]
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}

\begin{figure}
  Round robin:
\begin{code}
  sched step (it1, it2, ...)    = {it2, ..., it1}
  sched done (it1, it2, ...)    = {it2, ...}
  sched noStep (it1, it2, ...)  = {it2, ...}
  sched fork (it1, it2, ...)    = {it2, ..., it1}
\end{code}
  Browbound:
\begin{code}
  sched step (it1, it2, ...)    = {it1, it2, ...}
  sched noStep (it1, it2, ...)  = {it2, ...}
  sched done (it1, it2, ...)    = {it2, ...}
  sched fork (it1, it2, ...)    = {it1, it2, ...}
\end{code}
  Sequential:
\begin{code}
  sched step (it1, it2, ...)       = {it1, it2, ...}
  sched noStep (it1, it2, ...)     = {it1, it2, ...}
  sched done (it1, it2, ...)       = {it2, ...}
  sched fork (it1, it2, ... it1n)  = {itn, it1, it2, ...}
\end{code}
\caption{scheduling policies}
\end{figure}


\clearpage % TODO: remove again, but keep for now to not have the text be split across 4 pages.
\subsection{Formal Guarantees}

\begin{theorem}[Termination Sensitive Non-Interference (TSNI)]
  For any list of tasks |its1|, |its2|, |its2|, label |il|,
  IFC states |iS1|, |iS2|, |iS1'|, where
  \begin{equation} \label{eq:tsni-lhs}
    |its1| \approx_{|il|} |its2|
    \qquad \text{and} \qquad
    |iconf iS1 its1| |.->|^* |iconf iS1' its1'|
  \end{equation}
  then there exists a list of tasks |its2'| and an IFC state |iS2'| such that
  \begin{equation} \label{eq:tsni-rhs}
    |its1'| \approx_{|il|} |its2'|
     \qquad \text{and} \qquad
    |iconf iS2 its2| |.->|^* |iconf iS2' its2'|
    \ \text{.}
  \end{equation}
\end{theorem}

\begin{lemma}
  \label{lemma:tsni}
  For any list of tasks |its1|, |its2|, |its2|, label |il|,
  IFC states |iS1|, |iS2|, |iS1'|, where
  \begin{equation} \label{eq:tsni-lemma-lhs}
  |its1| \approx_{|il|} |its2|
  \qquad \text{and} \qquad
  |iconf iS1 its1| |.->| |iconf iS1' its1'|
  \end{equation}
  then there exists a list of tasks |its2'| and an IFC state |iS2'| such that
  \begin{equation} \label{eq:tsni-lemma-rhs}
  |its1'| \approx_{|il|} |its2'|
  \qquad \text{and} \qquad
  |iconf iS2 its2| |.->|^* |iconf iS2' its2'|
  \ \text{.}
  \end{equation}
\end{lemma}

\begin{proof}
  We proof the theorem by induction on the length of the derivation sequence in~\eqref{eq:tsni-lhs}.
  The base case for derivations
  of length 0 is trivial, allowing
  us to simple chose $|its2'=its2|$ and $|iS2'=iS2|$.  In the step case, we assume
  the theorem holds for derivation sequences of length up to $n$, and show that it also
  holds for those of length $n+1$.  We split the derivation sequence from~\eqref{eq:tsni-lhs} as follows:
  \[
  |iconf iS1 its1| |.->| |iconf iS1'' its1''| |.->|^n |iconf iS1' its1'|
  \]
  for some IFC state |iS1''| and task list |its1''|.  By Lemma~\ref{lemma:tsni}, we get
  |its2''| and |iS2''| with
  \begin{equation} \label{eq:tsni-proof-1}
  |its1''| \approx_{|il|} |its2''|
  \qquad \text{and} \qquad
  |iconf iS2 its2| |.->|^* |iconf iS2'' its2''|
  \end{equation}
  Applying the induction hypothesis to
  $|iconf iS1'' its1''| |.->|^n |iconf iS1' its1'|$, we get |its2'| and |iS2'| with
  \begin{equation} \label{eq:tsni-proof-2}
  |its1'| \approx_{|il|} |its2'|
  \qquad \text{and} \qquad
  |iconf iS2'' its2''| |.->|^* |iconf iS2' its2'|
  \end{equation}
  Stitching together the derivation sequences from~\eqref{eq:tsni-proof-1} and~\eqref{eq:tsni-proof-2} directly gives
  us~\eqref{eq:tsni-rhs}, which concludes the proof.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:tsni}]
  \Red{It seems that the theorem, lemma as well as the proofs need to talk
    about |il| equivalence of |iS|, too, not just |il| equivalence of tasks.}
  
  We proof the lemma by induction on the derivation
  for~\eqref{eq:tsni-lemma-lhs}, and consider all possible rules that
  could have been used to make the reduction step.  In all cases, there
  needs to exist a task |it1| at the beginning of the list of |its1|.
  Consider two cases:
  \begin{itemize}
    \item $|erase il it1|=|bullet|$. In this case, we do not need to take a
    step for
    |its2|, because |its2'=its2| will already be |il|-equivalent to |its'|.
    In particular, note that 
    To see that, note that all existing tasks in |its1| are left in the
    same order and unmodified, except for |it1| (which has no
    corresponding task in |its2|, since it gets filtered).  The task |it1|
    gets dropped (by \textsc{I-noStep}), or
    transforms into a new task |it1'| as well as potentially spawning a new
    task |it1''|.  Since both |it1'| and |it1''| have a label that is
    at least as high as the label of |it1|, they will also get filtered.
    
    \alphacondition{We need all scheduling policies to not change the order
      of any tasks (except for the first one).  Newly spawned task can appear
      anywhere in the list.}
    \item $|erase il it1|\neq|bullet|$.  Here, there must be a corresponding
    task |it2|, such that $|it1|\approx_{|il|}|it2|$ (otherwise |its1| and
    |its2| could not be |il| equivalent).
    However, |it2| might not be at the beginning of the task list yet, but
    all tasks occurring before it must get erased by |erasef il|.
    In |its2|, we can first take some number of steps until |it2| moves
    to the front of the list (\Red{Say more precisely why
      (basically because we require the scheduling policy to do that)}).
    
    \alphacondition{The scheduling policy must eventually let any task in
      the task list evaluate.  In particular, it cannot get stuck when the
      first task gets stuck, or keep executing a small number of tasks
      exclusively forever (e.g. just execute the first task all the time
      if it gets into an infinite loop).}
    
    Therefore, after |its2| has potentially executed some number of steps
    to arrive at |its2''|, we are now in the situation where $|its1|\approx_{|il|}|its2''|$, and the first task |it1| and |it2| don't
    get erased and are |il| equivalent.  We consider all
    possible rules used to derive~\eqref{eq:tsni-lemma-lhs}:
    \begin{description}
      \item[Case \textsc{I-done}] 
      \item[Case \textsc{I-noStep}] 
      \item[Case \textsc{I-fork}] 
      \item[Case \textsc{I-setLabel}]
    \end{description}
  \end{itemize}
\end{proof}

\subsection{Generalizing further}

\begin{itemize}
\item Label transition systems.
\item Non-deterministic reduction.
\item Arbitrary scheduling policies $\alpha$
\end{itemize}











