\section{Retrofitting languages with IFC}
\label{sec:retrofit}

While we would like to add information flow control to \emph{any}
language, we will have to make some assumptions about the form of the
target language.  We consider languages whose semantics can be expressed
in the form of abstract machines |(tS, tE, te, tv, ->)|, where |tS| is the
global machine state, |tE| is an evaluation context, |te| is an
expression in the language, |tv| is the set of values, and |->| is the reduction relation on such
configuration, i.e., $|->| : (|tS| \times |tE| \times |te|)
\rightharpoonup (|tS| \times |tE| \times |te|)$.  Metavariables in this
target language have been colored red.

In Figure~\ref{fig:ml}, we give an example of a standard ML-like
language with mutable references.  These semantics have been prepared
for interoperability in the style of Matthews and Findler~\Red{XXX}; in
particular, the evaluation rules have been expressed in terms of an
evaluation context $\mathcal{E}_{\tar{\Sigma}}$.  Without the embedding,
this evaluation context is defined as |conf tS te @= tS, tE[ te ]|, but
when we perform the embedding, we will reinterpret the meaning
of this evaluation context, lifting these semantics to an IFC setting.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
tty   ::= bool | tty -> tty | ref tty
te   ::= tv | tx | te te | if te then te else te | ref te | !te | te := te
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE 

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\Red{Suggestion: Only give the rules for references, because otherwise this is all standard.}

\begin{mathpar}

\and
\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{| tS' = tS [ ta mapsto tv ] | } 
{| conf tS (ref tv) -> conf tS' ta |}
{| fresh (ta) |}

\and
\inferrule[T-deref]
{| tv = tS(ta) |}
{| conf tS (!ta) -> conf tS tv |}

\and
\inferrule[T-ass]
{| tS' = tS [ ta mapsto tv ] |} 
{| conf tS (ta := tv) -> conf tS' tv |}
\end{mathpar}

\caption{Simple ML-like language |targetLangML|}
\label{fig:ml}
\end{figure}

Next, we describe the IFC language.  \Red{Description of the IFC language as
a standard floating label system, or backwards reference to the
background section.}  In Figure~\ref{fig:ifc}, we describe the syntax
of the language, and provide rules for all operations which operate on a single
thread.  \Red{One could imagine these rules giving the definition of a very
boring information flow control language, by defining |niconf iS id il ie| appropriately
and providing an appropriate erasure function.}

We use the notation |filter il Q| to indicate a filter function which removes message whose labels do not
flow to |il|. Specifically, if |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|; otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]

%   \begin{figure}
%   Typing judgment: $|tyrule tG tS te tty|$
%   \begin{mathpar}
%   \inferrule[T-ty-address]
%   {}
%   {| tyrule tG tS a (ref (tyLookup tS a)) |}
%   \end{mathpar}

%   \caption{Selected typing rules for ML-like language}
%   \label{fig:ml-typing}
%   \end{figure}

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie
       |  fork ie | send ie ie ie | ix1, ix2 <= recv. ie ie
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | fork iE 
       |  send iE ie ie | send iv iE ie | send iv iv iE
       |  ix1, ix2 <= recv. ie ie
io   ::=  (il, id ie)
Q    ::=  nil | io , Q
iS   ::=  emptyset | iS [ id mapsto Q ]
\end{code}

\begin{mathpar}

\and
\inferrule[I-getLabel]
{ }
{|
niconf iS id il getLabel
->
niconf iS id il il
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
niconf iS id il (setLabel il')
->
niconf iS id il' unit
|}
%{|fresh (id')|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
}
{|
niconf iS  id il (send id' il' ie)
->
niconf iS' id il unit
|}

\and
\inferrule[I-recv]
{
| filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
| iS' = iS[id mapsto io1 , ... , iok]|\\
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ({ie'/ix1,id'/ix2} ie1)
|}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = iS[id mapsto nil]|
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ie2
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |niconf iS id il (il1 lop il2) -> niconf iS id il iv| }
\end{mathpar}
\caption{IFC language, single-thread operations}
\label{fig:ifc}
\end{figure}

Finally, in Figure~\ref{fig:embedding},
we provide all of the rules responsible for actually carrying out the embedding:

\begin{itemize}
    \item We extend the values, expressions and evaluation contexts of both languages to allow for embeddings terms in one language to be embedded in the other.  \Red{For now, we defer discussion on how these boundaries mediate between the type systems of the two languages.}
    \item We reinterpret |CE| to be evaluation contexts on threadpools.  By assumption, only the first thread in the threadpool executes.
    \item We define |->|, operation on a single thread, in terms of |.->|, operation on thread pools.  The correspondence is simple: a thread executes a step, and then is rescheduled in the thread pool according to schedule policy $\alpha$. \Red{More on schedule policies later}
    \item Finally, we define some rules for scheduling, handling forking threads (which interact with the state of the target language) and intermediating between the borders of the two languages. \Red{As written, these rules will not preserve type-safety of the underyling language, but it is easy to adjust them to ensure they do so.}
\end{itemize}

The fork rule is of particular interest; it is defined in terms of a function $\kappa$.
Conservatively, $\kappa$ may be simply thought of as the identity function, in which
case the semantics of fork are such that the state of the target language is \emph{cloned}
when forking occurs.  However, this is not necessary: it is also valid for $\kappa$
to remove entries from the state.  \Red{For more information about when this is not the
fork semantics you want, see the concrete implementation section.}

\begin{figure}
%{
%format .->  = "\overset{\alpha}{\hookrightarrow}"
%format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
\begin{tabular}{ll}
\begin{minipage}{.22\textwidth}
\begin{code}
iv  ::= cdots | IT tv
ie  ::= cdots | IT te
iE  ::= cdots | IT tE
\end{code}
\end{minipage} &
\begin{minipage}{.22\textwidth}
\begin{code}
tv  ::= cdots | TI iv
te  ::= cdots | TI ie
tE  ::= cdots | TI iE
\end{code}
\end{minipage}
\end{tabular}

\begin{code}
ix1, ix2 <= brecv . ie @= IT (let tx = TI (ix1, ix2 <= recv. ie  (IT tx)) in tx)
conf tS te @= iconf iS (fullconf id il tS (iniEt te), ldots)
niconf iS id il ie @= iconf iS (fullconf id il tS (iniEi ie), ldots)
CE[e] -> iconf iS (it, ldots) @= CE[e] .-> iconf iS (sched step (it, ldots))
\end{code}

\begin{mathpar}
\inferrule[I-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|tS' = klone(tS)|\\
|it1 = fullconf id il tS (iniE id')|\\
|itnew = fullconf id' il tS' (TI ie)|\\
|fresh (id')|
}
{|
iconf iS (fullconf id il tS (iniEi (fork ie)), ldots)
.->
iS'; sched F (it1, ldots, itnew)
|}

\and
\inferrule[I-done]
{|
|}
{|
iconf iS (fullconf id il tS iv, ldots)
.->
iS ; sched D (fullconf id il tS iv, ldots)
|}

\and
\inferrule[I-noStep]
{|
iconf iS (it, ldots) .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched N (it, ldots)
|}

\and
\inferrule[I-border]
{ }
{|
niconf iS id il (IT (TI (ie)))
->
niconf iS id il ie
|}

\and
\inferrule[T-border]
{ } {| conf tS (TI (IT (te))) -> conf tS te|}
\end{mathpar}
\caption{The embedding |specLang alpha (targetLang nop)|, where
|targetLang nop = (tS, tE, te, tv, ->)|}
\label{fig:embedding}
%}
\end{figure}


\Red{When both languages have booleans, it is relatively simple to define
a natural embedding which preserves booleans across boundaries.}
\begin{mathpar}
\inferrule[I-bool]
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule[T-bool]
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}

\begin{figure}
  Concurrent, round robin:
\begin{code}
  roundrobin step (it1, it2, ldots)  = it2, ldots, it1
  roundrobin D (it1, it2, ldots)     = it2, ldots
  roundrobin N (it1, it2, ldots)     = it2, ldots
  roundrobin F (it1, it2, ldots)     = it2, ldots, it1
\end{code}
  Sequential:
\begin{code}
  seq step (it1, it2, ldots)     = it1, it2, ldots
  seq N (it1, it2, ldots)        = it1, it2, ldots
  seq D (it)                     = it
  seq D (it1, it2, ldots)        = it2, ldots
  seq F (it1, it2, ldots, itn)   = itn, it1, it2, ldots
\end{code}
\caption{Scheduling policies}
\end{figure}


\subsection{Generalizing further}

\begin{itemize}
\item Label transition systems.
\item Non-deterministic reduction.
\item Arbitrary scheduling policies $\alpha$
\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
