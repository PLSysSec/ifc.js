\section{Retrofitting languages with IFC}
\label{sec:retrofit}


We consider languages in the form of abstract state machines |(tS, tE,
te, ->)|, where |tS| is the global machine state, |tE| is an evaluation
context, |te| is an expression in the language and |->| is the
reduction relation on such configuration, i.e., $|->| : (|tS| \times
|tE| \times |te|) \rightharpoonup (|tS| \times |tE| \times |te|)$


To get the flavor for our approach, we will first show how our embedding
works for a simple, ML-like language, with references and general recursion.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
te   ::= tv | tx | te te | if te then te else te | ref te | !te | te := te | diverge
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE 

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\begin{mathpar}
\and
\inferrule[T-evalCtx]
{| conf tS te -> conf tS' te')|}
{| conf tS (intE te) -> conf tS' (intE te') |}

\and
\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) ~> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2)  ~> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2)  ~> conf tS te2|}

\and
\inferrule[T-ref]
{| tS' = tS [ ta mapsto tv ] | } 
{| conf tS (ref tv) -> conf tS' ta |}
{| fresh (ta) |}

\and
\inferrule[T-deref]
{| tv = tS(ta) |}
{| conf tS (!ta) -> conf tS tv |}

\and
\inferrule[T-ass]
{| tS' = tS [ ta mapsto tv ] |} 
{| conf tS (ta := tv) -> conf tS' tv |}
\end{mathpar}

\caption{Simple ML-like language}
\label{fig:ml}
\end{figure}

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie
       |  fork ie | send ie ie ie | ix1, ix2 <= recv. ie ie |  IT te
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | fork iE 
       |  send iE ie ie | send iv iE ie | send iv iv iE
       |  ix1, ix2 <= recv. ie ie |  IT tE
io   ::=  (il, id ie)
Q    ::=  nil | io , Q

te   ::=  cdots | TI ie
tE   ::=  cdots | TI iE


ix1, ix2 <= brecv . ie @= IT (let tx = TI (ix1, ix2 <= recv. ie  (IT tx)) in tx)
\end{code}

\begin{mathpar}
\inferrule[I-evalCtx]
{|
iconf iS (tconf id il ie)
.->
iconf iS' (tconf id il' ie')
|}
{|
iS ,(iniTE (lconf id il tS (iniE ie)))
.-.>
iS', (iniTE (lconf id il' tS (iniE ie')))
|}

\and
\inferrule[I-step]
{|
conf tS (te) -> conf tS' te'
|}
{|
iS, (iniTE (lconf id il tS (IT te)))
.-.>
iS, (iniTE (lconf id il tS' (IT te')))
|}

%% \and
%% \inferrule[I-getLabel]
%% { }
%% {|
%% iconf iS (lconf id il tS getLabel, ldots)
%% .->
%% iconf iS (lconf id il tS il, ldots)
%% |}

\and
\inferrule[I-getLabel]
{ }
{|
iconf iS (tconf id il getLabel)
.->
iconf iS (tconf id il il)
|}

%% \and
%% \inferrule[I-setLabel]
%% { |il canFlowTo il'| }
%% {|
%% iconf iS (lconf id il tS (iniE (setLabel il')), ldots)
%% .->
%% iconf iS (lconf id il' tS (iniE unit), ldots)
%% |}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
iconf iS (tconf id il (setLabel il'))
.->
iconf iS (tconf id il' unit)
|}

\and
\inferrule[I-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|tS' = q(tS)|\\
|fresh (id')|\\
|iTE' THole = iniTE (lconf id il tS id'), THole|
}
{|
iS, iniTE (lconf id il tS (fork ie))
.-.>
iS', iniTE' (lconf id' il tS' (TI ie))
|}
%{|fresh (id')|}

%% \and
%% \inferrule[I-send]
%% {
%% |il canFlowTo il'|\\
%% |iS(id') = Q|\\
%% |iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
%% }
%% {|
%% iconf iS (lconf id il tS (iniE (send id' il' ie))), ldots)
%% .->
%% iconf iS' (lconf id il tS (iniE unit), ldots)
%% |}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
}
{|
iconf iS  (tconf id il (send id' il' ie))
.->
iconf iS' (tconf id il unit)
|}

%% \and
%% \inferrule[I-recv]
%% {
%% | filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
%% | iS' = iS[id mapsto io1 , ... , iok]|\\
%% | ie1'' = {ie'/ix1,id'/ix2} ie1|
%% }
%% {|
%% iconf iS (lconf id il tS (iniE (ix1, ix2 <= recv. ie1 ie2)), ldots)
%% .->
%% iconf iS' (lconf id il tS (iniE ie1''), ldots)
%% |}

\and
\inferrule[I-recv]
{
| filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
| iS' = iS[id mapsto io1 , ... , iok]|\\
}
{|
iconf iS  (tconf id il (ix1, ix2 <= recv. ie1 ie2))
.->
iconf iS' (tconf id il ({ie'/ix1,id'/ix2} ie1))
|}

%% \and
%% \inferrule[I-noRecv]
%% {
%% | filter il (iS(id)) = nil|\\
%% | iS' = iS[id mapsto nil]|
%% }
%% {|
%% iconf iS (lconf id il tS (iniE (ix1, ix2 <= recv. ie1 ie2)), ldots)
%% .->
%% iconf iS' (lconf id il tS (iniE ie2), ldots)
%% |}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = iS[id mapsto nil]|
}
{|
iconf iS  (tconf id il (ix1, ix2 <= recv. ie1 ie2))
.->
iconf iS' (tconf id il ie2)
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |iconf iS (tconf id il (il1 lop il2)) .-> iconf iS (tconf id il iv)| }

\and
\inferrule[I-border]
{ }
{|
iconf iS (tconf id il (IT (TI (ie))))
.->
iconf iS (tconf id il ie)
|}

\and
\inferrule[T-border]
{ } {| conf tS (intE (TI (IT (te)))) -> conf tS (intE te)|}
\end{mathpar}
\caption{IFC language nad general embedding.}
\label{fig:ml}
\end{figure}

The filter function |filter il Q| removes message whose labels do not
flow to |il|. Specifically, if |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|; otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]


In the case of extending
\begin{mathpar}
\inferrule[I-bool]
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule[T-bool]
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}



\subsection{Generalizing further}

\begin{itemize}
\item Label transition systems.
\item Non-deterministic reduction.
\item Arbitrary scheduling policies $\alpha$
\end{itemize}
