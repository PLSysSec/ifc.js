\section{Retrofitting Languages with IFC}
\label{sec:retrofit}

Our overall plan will be to take a \textbf{{\color{red} target
language}} with a formal operational semantics and combine it with an
\textit{{\color{blue} information flow control language}}.  For example,
taking ECMAScript as the target language and combining it with our IFC
language should produce the formal semantics for SWAPI.  In this
presentation, we use a simple, untyped lambda calculus with mutable
references and fixpoint in place of ECMAScript, to demonstrate some of the key
properties without having too much detail; we discuss the proper
embedding in more detail in Section~\ref{sec:real}.

\paragraph{Notation}
We have typeset nonterminals of the target language using \textbf{{\color{red}
bold font}} while the nonterminals of the IFC language have been typeset
with \textit{{\color{blue} italic font}}.  Readers are encouraged to view
a color copy of this paper, where target language nonterminals are colored \textbf{{\color{red} red}}
while IFC language nonterminals are colored \textit{{\color{blue} blue}}.

\subsection{Target Language: Mini-ES}

In Figure~\ref{fig:ml}, we give a simple, untyped lambda calculus with
mutable references and fixpoint, prepared for combination with an
information flow control language.  The presentation is mostly standard, and utilizes Felleisen-Hieb reduction
semantics~\cite{Felleisen:1992:RRS:136293.136297} to define the
operational semantics of the system.  One peculiarity is that our language
defines an evaluation context |tE|, but, the evaluation rules have been
expressed in terms of a different evaluation context |curlyRedE|;
Here, we follow the approach of Matthews and
Findler~\cite{Matthews:2007:OSM:1190216.1190220} in order to simplify combining
semantics of multiple languages. 
To derive the usual operational semantics for this language, the evaluation
context merely needs to be defined as |conf tS te @= tS, bracket tE te|.
However, when we combine this language with an IFC language, we
reinterpret the meaning of this evaluation context.

In general, we require that a target language be expressed in terms
of some global machine state |tS|, some evaluation context |tE|,
some expressions |te|, some set of values |tv| and a \emph{deterministic}
reduction relation on full configurations $|tS| \times |tE| \times |te|$.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
te   ::= tv | tx | te te | if te then te else te
       | ref te | !te | te := te | fix te
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE | fix tE

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\begin{mathpar}

\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{ | ap fresh ta | }
{| conf tS (ref tv) -> conf (bracket tS (mapsto ta tv)) ta |}

\and
\inferrule[T-deref]
{ |memberf ((ta, tv)) tS| }
{| conf tS (!ta) -> conf tS (tv) |}

\and
\inferrule[T-ass]
{ }
{| conf tS (ta := tv) -> conf (bracket tS (mapsto ta tv)) tv |}

\and
\inferrule[T-fix]
{ }
{| conf tS (fix (\ x . e)) -> conf tS ({fix (\ x . e)/x} e) |}

%\and
%\inferrule[T-fail]
%{ }
%{| conf tS ( tE [ fail ] ) -> conf tS fail |}
\end{mathpar}

\caption{|targetLangML|: simple untyped lambda calculus extended with booleans,
mutable references and general recursion. |FV(te)| returns the set of free
variables in express |te|.}
\label{fig:ml}
\end{figure}

\subsection{IFC Language}

Most modern, dynamic information flow control languages encode
policy by associating a \emph{label}
with data, which encodes whether or not data tagged with one
label |l1| can flow to another label |l2| (written as |canFlowTo2 l1 l2|).
Our embedding is agnostic to the choice of labeling scheme; we only
require the labels to form a lattice~\cite{Denning:1976:LMS:360051.360056}
with the partial order |canFlowTo|, join |lub|, and meet |glb|.
In this paper, we simply represent labels with the metavariable
$l$, but do not discuss them in more detail.

As opposed to more traditional fine-grained language-based IFC systems that
associate labels with values~\cite{sabelfeld2003language,
Austin:Flanagan:PLAS09}, we follow~\cite{Zeldovich:2006, lio} in taking a
coarse-grained floating-label approach and associating labels with
\emph{tasks}.
%
The task label---we refer to the label of the currently executing task as the
\emph{current label}---serves to protect everything in the task's scope;
all data in a task shares this common label.
%
Hence before performing a reads or a write, the IFC monitor inspects the
current label to decide whether the operation is permitted.
%
A task can only write to entities that are at least as sensitive.
%
Similarly, it can only read from entities that are less sensitive.
%
However, as in other floating-label systems, this current label can be raised
to allow the task to read from more sensitive entities at the cost of giving up
the ability to write to certain entities.

In Figure~\ref{fig:ifc}, we give the syntax and \emph{single-task}
evaluation rules for a minimal information-flow control language.  
Ordinarily, information flow control languages are defined by directly
stating a base language plus information flow control operators.  In
contrast, our language is purposely minimal: it does not have sequencing
operations, control flow, or other constructs.  However, it contains
support for the following core information flow control features:

\begin{itemize}
    \item First-class labels, with label values $l$ as well as operations for computing on
labels (|canFlowTo|, |lub| and |glb|).
    \item Operations for inspecting (\textbf{getLabel}) and modifying
    (\textbf{setLabel}) the current label of the task (a task can only increase its label),
    \item Operations for non-blocking inter-task communication (\textbf{send}
    and \textbf{recv}), which interact with the global store of per-task
    message queues |iS|, and
%%     Labels are associated with message at the time of
%%     the send; the label on a message must always be at least as sensitive as that
%%     of the sending thread, since, conceptually, once a message is put on a
%%     message queue it is no longer protected by the current label, rather it is
%%     protected by the message label.
%%     Dually, when reading a message with |recv| the current label of the
%%     receiver must be at least as high as the message label.
    \item A sandboxing operation used to spawn new isolated tasks. In
    concurrent settings |fork| corresponds to a fork-like primitive,
    whereas in a
    sequential setting, it more closely resembles the LIO's
    |toLabeled|~\cite{lio}, and the Breeze
    bracket~\cite{Hritcu:2013:YIB:2497621.2498098}.
\end{itemize}

These operations are all defined with respect to an evaluation context
|curlyBlueE| that represents the context of the current task which, by
conventions is running. The evaluation context has three important pieces of
state: the global message queues |iS|, the current label |il| and the task ID |id|.
 
We note that first class labels, tasks (albeit named differently), and
operations for inspecting the current label are are essentially universal to
all floating-label systems.
%
However, our choice of communication primitives is motivated by
those present in browsers, namely \texttt{postMessage}~\cite{webmessaging}.
%
Of course, other choices, such as blocking communication or labeled channels,
are possible (see Section~\ref{sec:extensions}).
%

These asynchronous communication primitives are worth further
discussion.  When a task is sending a message using |send|, it also labels that
message with a label |il'| (which must be above the tasks current label |il|).
Messages can only be received by a task if its current label is
at least as high as the label of the message.
Specifically, receiving a message using
\[ |recvf ix1 ix2 ie1 ie2| \]
binds the message and the senders task identifier
to local variables |ix1| and |ix2|, respectively, and then executes |ie1|.
Otherwise the message gets removed from the queue by rule \textsc{I-noRecv},
and that tasks continues its execution with |ie2|.
We denote the filtering of the message queue by |filter il Q|,
which is defined as follows.
If |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|, and otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]
This ensures that tasks cannot receive messages that are more sensitive
than their current label would allow.

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie | getTaskId
       |  sandbox ie | send ie ie ie | recvf ix ix ie ie
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | sandbox iE
       |  send iE ie ie | send iv iE ie | send iv iv iE
io   ::=  (il, id ie)
Q    ::=  nil | io , Q
iS   ::=  emptyset | bracket iS (mapsto id Q)
\end{code}

\begin{mathpar}

\inferrule[I-getTaskId]
{ }
{|
niconf iS id il getTaskId
->
niconf iS id il id
|}

\and
\inferrule[I-getLabel]
{ }
{|
niconf iS id il getLabel
->
niconf iS id il il
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
niconf iS id il (setLabel il')
->
niconf iS id il' unit
|}
%{|fresh (id')|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = bracket iS (mapsto id' (il', id,  iv) , Q)|
}
{|
niconf iS  id il (send id' il' iv)
->
niconf iS' id il unit
|}

\and
\inferrule[I-recv]
{
| (filter il (iS(id))) = io1 , ... , iok , (il', id', iv)|\\
| iS' = bracket iS (mapsto id (io1 , ... , iok))|\\
}
{|
niconf iS  id il (recvf ix1 ix2 ie1 ie2)
->
niconf iS' id il ({iv/ix1,id'/ix2} ie1)
|}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = bracket iS (mapsto id nil)|
}
{|
niconf iS  id il (recvf ix1 ix2 ie1 ie2)
->
niconf iS' id il ie2
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |niconf iS id il (il1 lop il2) -> niconf iS id il iv| }
\end{mathpar}
\caption{IFC language with all single-task operations.}
\label{fig:ifc}
\end{figure}

\subsection{The Embedding}
Figure~\ref{fig:embedding}
provides all of the rules responsible for actually carrying out the embedding of the IFC language with the target language.
The most important feature of this embedding is that every task maintains its own
copy of the target language global state and evaluation context, thus
enforcing isolation between various tasks.  In more detail:

\begin{figure}
%{
%format .->  = "\overset{\alpha}{\hookrightarrow}"
%format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
\begin{tabular}{ll}
\begin{minipage}{.22\textwidth}
\begin{code}
iv  ::= cdots | IT tv
ie  ::= cdots | IT te
iE  ::= cdots | IT tE
\end{code}
\end{minipage} &
\begin{minipage}{.22\textwidth}
\begin{code}
tv  ::= cdots | TI iv
te  ::= cdots | TI ie
tE  ::= cdots | TI iE
\end{code}
\end{minipage}
\end{tabular}

\begin{code}
conf tS te @= iconf iS (fullconf id il tS (iniEt te), ldots)
niconf iS id il ie @= iconf iS (fullconf id il tS (iniEi ie), ldots)
CE[e] -> iconf iS (it, ldots) @= CE[e] .-> iconf iS (sched step (it, ldots))
\end{code}

\begin{mathpar}
\inferrule[I-sandbox]
{ 
|iS' = bracket iS (mapsto id' nil)|\\
|tS' = klone(tS)|\\
|it1 = fullconf id il tS (iniE id')|\\
|itnew = fullconf id' il tS' (TI ie)|\\
|ap fresh id'|
}
{|
iconf iS (fullconf id il tS (iniEi (sandbox ie)), ldots)
.->
iS'; sched box (it1, ldots, itnew)
|}

\and
\inferrule[I-done]
{|
|}
{|
iconf iS (fullconf id il tS iv, ldots)
.->
iS ; sched done (fullconf id il tS iv, ldots)
|}

\and
\inferrule[I-noStep]
{|
iconf iS (it, ldots) .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched nostep (it, ldots)
|}

\and
\inferrule[I-border]
{ }
{|
niconf iS id il (IT (TI (ie)))
->
niconf iS id il ie
|}

\and
\inferrule[T-border]
{ } {| conf tS (TI (IT (te))) -> conf tS te|}
\end{mathpar}
\caption{The embedding |specLang alpha (targetLang nop)|, where
|targetLang nop = (tS, tE, te, tv, ->)|}
\label{fig:embedding}
%}
\end{figure}

\begin{itemize}
    \item We extend the values, expressions and evaluation contexts of both languages to allow for embeddings terms in one language to be embedded in the other.~\cite{Matthews:2007:OSM:1190216.1190220}
    %
In the target language, an IFC expression appears as |TI ie| (``target-outside,
IFC-inside''); in the IFC language, a target language expression appears as |IT
te| ( ``IFC-outside, target-inside'').
    \item We reinterpret |CE| to be evaluation contexts on task lists, providing definitions for |curlyRedE| and |curlyBlueE|.  These rules only operate on the first task in the task list, which by convention is the only task executing.
    \item We reinterpret |->|, an operation on a single task, in terms of |.->|, operation on task lists.  The correspondence is simple: a task executes a step and then is rescheduled in the task list according to schedule policy |alpha|.
    Figure~\ref{fig:scheduler} defines two concrete schedulers.
    \item Finally, we define some rules for scheduling, handling sandboxing tasks (which interact with the state of the target language),
    and intermediating between the borders of the two languages.
\end{itemize}

\begin{figure}
  Concurrent, round robin:
\begin{code}
  roundrobin step (it1, it2, ldots)  = it2, ldots, it1
  roundrobin done (it1, it2, ldots)     = it2, ldots
  roundrobin nostep (it1, it2, ldots)     = it2, ldots
  roundrobin box (it1, it2, ldots)     = it2, ldots, it1
\end{code}
  Sequential:
\begin{code}
  seq step (it1, it2, ldots)     = it1, it2, ldots
  seq nostep (it1, it2, ldots)        = it1, it2, ldots
  seq done (it)                     = it
  seq done (it1, it2, ldots)        = it2, ldots
  seq box (it1, it2, ldots, itn)   = itn, it1, it2, ldots
\end{code}
\caption{Scheduling policies}
\label{fig:scheduler}
\end{figure}

The \textsc{I-sandbox} rule is used to create a new isolated task that
executes separately from the existing tasks (and can be communicated
with via |send| and |recv|).  When the new task is created, there
is the question of what the target language state of the new task should
be.  Our rule is stated generically in terms of a function |klone|.
Conservatively, |klone| may be simply thought of as the identity
function, in which
case the semantics of sandbox are such that the state of the target language is \emph{cloned}
when sandboxing occurs.  However, this is not necessary: it is also valid for |klone|
to remove entries from the state.  In Section~\ref{sec:concrete}, we give a more detailed
discussion of the implications of the choice of |klone|, but all our
security claims will hold regardless of the choice of |klone|.

The rule \textsc{I-noStep} says something about configurations for which
it is not possible to take a transition.  The notation
$|ic|\not\overset{\alpha}{\hookrightarrow}$ in the premise
is meant to be understood as
follows:  If the configuration |ic| cannot take a step by any rule other
than \textsc{I-noStep}, then \textsc{I-noStep} applies and the
stuck task gets removed.

Rules \textsc{I-done} and \textsc{I-noStep} define the behavior of the system
when the current thread has reduced to a value, or gotten stuck, respectively.
%
While these definitions simply rely on the underlying scheduling policy,
|alpha|, to modify the task list, as we describe in Sections~\ref{sec:formal}
and~\ref{sec:extensions}, these rules (notably, \textsc{I-noStep}) are crucial
to proving our security guarantees.
%
For instance, it is unsafe for the whole system to get stuck if a particular
task gets stuck, since a sensitive thread may then leverage this to leak
information through the termination channel.
%
Instead, as our example |roundrobinf| scheduler shows, such tasks should simply
be removed from the task list.

%
As in~\cite{Matthews:2007:OSM:1190216.1190220}, rules \textsc{T-border} and
\textsc{I-border} define the syntactic boundaries between the IFC and target
languages.
%
Intuitively, the boundaries respectively correspond to an upcall into and
downcall from the IFC runtime.
%
As an example, taking |targetLangML| as the target languge, we can now define a
blocking receive (inefficiently) in terms of the asynchronous |recv| as series
of cross-language calls:
\begin{code}
  brecvf ix1 ix2 ie @=
  tab tab tab (IT (fix (\ k . TI (recvf ix1 ix2 ie (IT k)) )))
\end{code}

We note that our embedding corresponds to the lump embedding
of~\cite{Matthews:2007:OSM:1190216.1190220} where terms in one language are
treated opaquely in the other.
%
Indeed since our embedding is defined for an arbitrary language |targetLang|,
we cannot do better.
%
However, when we have more information about the target language, it is
possible to add rules for a natural embedding of expressions that occur in both
languages.  In our specific example with |targetLangML|, we can choose to
preserve booleans across language boundaries as follows:
\begin{mathpar}
\inferrule
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}

For any target language |targetLang| and scheduling policy |alpha|, this
embedding defines an IFC language, which we will
refer to as |specLang alpha targetLang|.

\subsection{Examples}

To get a feeling for how these operational semantics operate, we
describe a few sample programs, and their corresponding behavior.

\paragraph{Sending mutable references}  As each task maintains its own
global state for the target language, one might reasonably wonder what would
happen if you attempted to send a reference to another task.
\begin{align*}
    & |let i = TI (sandbox (brecvf x i' (IT (!(TI x)))))|\\
    & |in TI (send (IT i) getLabel (IT (ref true)))|
\end{align*}
It would be a violation of information flow if such an operation actually
resulted in references being shared between two tasks.  In fact, the address
will be received by the sandboxed task, but it will be a dangling pointer; the
task will get stuck (under the |roundrobinf| scheduler the \textsc{I-noStep} will in turn remove it from the task list).  Readers
who are curious whether or not a static discipline could be enforced to
prevent these dangling pointers should check Section~\ref{sec:extensions}.

\paragraph{Status of the heap after a sandbox}  Consider a program whose
semantics depends on the definition of |klone|:
\begin{align*}
    & |let x = ref true| \\
    & |in TI (sandbox (IT (!x; !x))); x := false|
\end{align*}
When |klone| is the identity, the sandboxed task successfully dereferences
the contents of the reference to be |true| twice (recall that references
are cloned into the new global state).  When |klone| is the constant function
to the empty store, |x| is a dangling pointer.

\paragraph{Exceptions}  One language feature that has caused difficulty for
many information flow control systems is handling exceptions.
%
The key difficulty appears when considering the propagation of exceptions
across stack boundaries where the current label is restored, e.g., from secret
to public, as done by LIO's |toLabeled| and Breeze's
brackets~\cite{Hritcu:2013:YIB:2497621.2498098, stefan:2012:arxiv-flexible}.
%
If the exception crosses this boundary, it can leak information about the
inner secret computation into a public computation; hence, both systems
explicitly ensure that |toLabeled| does not propagate exceptions.

Our general embedding approach provides these semantics by construction.
%
To show this, we first define an encoding of the sequential |toLabeled|
construct in our framework:
\begin{align*}
    & |toLabeled l te @= | \\
    & |tab let i = taskId; | \\
    & |tab let j = TI (sandbox (IT (TI (setLabel l); TI (send i l (IT te)))))| \\
    & |tab in (\ _ . TI (setLabel l); TI (recvf x _ x unit))|
\end{align*}
When using the sequential scheduler |seqf|, the sandboxed task runs to
completion before returning to the task that sandboxed it. 
(Here, a task list can be interpreted as a number of information flow aware
stack frames.)
To read the result of a |toLabeled| operation
(which is communicated via message passing), the parent task must raise
its label; otherwise the label will get dropped, as per the \textsc{I-recv}
rule.\footnote{A keen reader may note that with a single, per-task channel, we
might mix up our messages.  Indeed, a proper development requires the ability
to allocate fresh channels; for purposes of simplicity, this has been omitted.}

Now suppose that our |targetLangML| is extended with a single exception
expression |fail|, which reduces to |fail|, removing all containing |tE|
evaluation contexts, i.e., it propagates up to a |IT (-)| boundary.
%
In this setting, it is clear that exceptions cannot cross boundaries.
%
For instance, 
\begin{code}
TI(toLabeled l (IT (if te then fail else true))); true
\end{code}
always evaluates to |true|, regardless of the value of |te|.
%
Just like in both LIO and Breeze, however, only when calling |recv| on such messages
will the exception be propagated.
%
This of course, is not a leak since the current label must be raised before
receiving sensitive message, regardless of their content.


