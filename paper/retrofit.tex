\section{Retrofitting languages with IFC}
\label{sec:retrofit}


We consider languages in the form of abstract state machines |(tS, tE,
te, ->)|, where |tS| is the global machine state, |tE| is an evaluation
context, |te| is an expression in the language and |->| is the
reduction relation on such configuration, i.e., $|->| : (|tS| \times
|tE| \times |te|) \rightharpoonup (|tS| \times |tE| \times |te|)$ \Red{This doesn't match the way the evaluation rules are currently done with a frame rule}


To get the flavor for our approach, we will first show how our embedding
works for a simple, ML-like language, with references and general recursion.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
tt   ::= bool | tt -> tt | ref tt
te   ::= tv | tx | te te | if te then te else te | ref te | !te | te := te
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE 

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

Typing judgment: $|tyrule tG tS te tt|$

\begin{mathpar}
\and
\inferrule[T-evalCtx]
{| conf tS te -> conf tS' te')|}
{| conf tS (intE te) -> conf tS' (intE te') |}

\and
\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{| tS' = tS [ ta mapsto tv ] | } 
{| conf tS (ref tv) -> conf tS' ta |}
{| fresh (ta) |}

\and
\inferrule[T-deref]
{| tv = tS(ta) |}
{| conf tS (!ta) -> conf tS tv |}

\and
\inferrule[T-ass]
{| tS' = tS [ ta mapsto tv ] |} 
{| conf tS (ta := tv) -> conf tS' tv |}
\end{mathpar}

\caption{Simple ML-like language}
\label{fig:ml}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule[T-ty-address]
{}
{| tyrule tG tS a (ref (tyLookup tS a)) |}
\end{mathpar}

\caption{Selected typing rules for ML-like language}
\label{fig:ml-typing}
\end{figure}

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit | IT tv
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie
       |  fork ie | send ie ie ie | ix1, ix2 <= recv. ie ie |  IT te
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | fork iE 
       |  send iE ie ie | send iv iE ie | send iv iv iE
       |  ix1, ix2 <= recv. ie ie |  IT tE
io   ::=  (il, id ie)
Q    ::=  nil | io , Q

te   ::=  cdots | TI ie
tE   ::=  cdots | TI iE

ix1, ix2 <= brecv . ie @= IT (let tx = TI (ix1, ix2 <= recv. ie  (IT tx)) in tx)
\end{code}
\caption{IFC grammar.}
\label{fig:ifc-grammar}
\end{figure}

\begin{figure}
\begin{align*}
  &|erase il (iconf iS its) =
  iconf (erase il iS) (fltr (\ lconf id il' tS te . te = bullet) (map (erasef il) its))| \\
  &|erase il (tconf id il' ie) =| \begin{cases}
    |tconf id il' bullet| & |il' cantFlowTo il| \\
    |tconf id il' (erase il ie)| & \text{otherwise}
  \end{cases} \\
  %&|erase il iS [i mapsto Q] = iS [i mapsto (erase il Q)]|\\
  &|erase il ((il', id, ie), Q) =| \begin{cases}
    |erase il Q| & |il' cantFlowTo il| \\
    |(il', id, ie), (erase il Q)| & \text{otherwise}
  \end{cases} \\
  &|erase il (send ie1 ie2 ie3) =| \begin{cases}
    |send ie1 ie2 bullet| & |ie2 cantFlowTo il| \\
    |send ie1 ie2 (erase il ie3)| & \text{otherwise}
  \end{cases} \\
  &\text{In all other cases, |erasef il| is applied homomorphically.}
\end{align*}
\caption{Erasure function.}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule[I-evalCtx]
{|
iconf iS (tconf id il ie)
.->
iconf iS' (tconf id il' ie')
|}
{|
iconf iS (lconf id il tS (iniE ie), ldots)
.->
iS' ; sched step (lconf id il' tS (iniE ie'), ldots)
|}

\and
\inferrule[I-done]
{|
|}
{|
iconf iS (lconf id il tS iv, ldots)
.->
iS ; sched done (lconf id il tS iv, ldots)
|}

\and
\inferrule[I-stepT]
{|
conf tS (te) -> conf tS' te'
|}
{|
iconf iS (lconf id il tS (iniE (IT te)), ldots)
.->
iS ; sched step (lconf id il tS' (iniE (IT te')), ldots)
|}

\and
\inferrule[I-noStepT]
{|
conf tS (te) -/> 
|}
{|
iconf iS (lconf id il tS (iniE (IT te)), ldots)
.->
iS ; sched noStep (lconf id il tS (iniE (IT te)), ldots)
|}

\and
\inferrule[I-noStep]
{|
it .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched noStep (it, ldots)
|}

\and
\inferrule[I-getLabel]
{ }
{|
iconf iS (tconf id il getLabel)
.->
iconf iS (tconf id il il)
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
iconf iS (tconf id il (setLabel il'))
.->
iconf iS (tconf id il' unit)
|}

\and
\inferrule[I-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|tS' = klone(tS)|\\
|it1 = lconf id il tS (iniE id')|\\
|itnew = lconf id' il tS' (TI ie)|\\
|fresh (id')|
}
{|
iconf iS (lconf id il tS (iniE (fork ie)), ldots)
.->
iS'; sched fork (it1, ldots, itnew)
|}
%{|fresh (id')|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
}
{|
iconf iS  (tconf id il (send id' il' ie))
.->
iconf iS' (tconf id il unit)
|}

\and
\inferrule[I-recv]
{
| filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
| iS' = iS[id mapsto io1 , ... , iok]|\\
}
{|
iconf iS  (tconf id il (ix1, ix2 <= recv. ie1 ie2))
.->
iconf iS' (tconf id il ({ie'/ix1,id'/ix2} ie1))
|}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = iS[id mapsto nil]|
}
{|
iconf iS  (tconf id il (ix1, ix2 <= recv. ie1 ie2))
.->
iconf iS' (tconf id il ie2)
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |iconf iS (tconf id il (il1 lop il2)) .-> iconf iS (tconf id il iv)| }

\and
\inferrule[I-border]
{ }
{|
iconf iS (tconf id il (IT (TI (ie))))
.->
iconf iS (tconf id il ie)
|}

\and
\inferrule[T-border]
{ } {| conf tS (intE (TI (IT (te)))) -> conf tS (intE te)|}
\end{mathpar}
\caption{IFC language and general embedding.}
\label{fig:ifc}
\end{figure}

The filter function |filter il Q| removes message whose labels do not
flow to |il|. Specifically, if |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|; otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]


In the case of extending
\begin{mathpar}
\inferrule[I-bool]
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule[T-bool]
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}

\begin{figure}
  Round robin:
\begin{code}
  sched step (it1, it2, ...)    = {it2, ..., it1}
  sched done (it1, it2, ...)    = {it2, ...}
  sched noStep (it1, it2, ...)  = {it2, ...}
  sched fork (it1, it2, ...)    = {it2, ..., it1}
\end{code}
  Browbound:
\begin{code}
  sched step (it1, it2, ...)    = {it1, it2, ...}
  sched noStep (it1, it2, ...)  = {it2, ...}
  sched done (it1, it2, ...)    = {it2, ...}
  sched fork (it1, it2, ...)    = {it1, it2, ...}
\end{code}
  Sequential:
\begin{code}
  sched step (it1, it2, ...)       = {it1, it2, ...}
  sched noStep (it1, it2, ...)     = {it1, it2, ...}
  sched done (it1, it2, ...)       = {it2, ...}
  sched fork (it1, it2, ... it1n)  = {itn, it1, it2, ...}
\end{code}
\caption{scheduling policies}
\end{figure}



\subsection{Formal Guarantees}

\begin{theorem}[Termination Sensitive Non-Interference (TSNI)]
  For any two list of tasks |its1|, |its2|, |its2|, label |il|,
  IFC states |iS1|, |iS2|, |iS1'|, where
  \begin{equation} \label{eq:tsni-lhs}
    |its1| \approx_{|il|} |its2|
    \qquad \text{and} \qquad
    |iconf iS1 its1| |.->|^* |iconf iS1' its1'|
  \end{equation}
  then there exists a list of tasks |ts2'| and an IFC state |iS2'| such that
  \begin{equation} \label{eq:tsni-rhs}
    |its1'| \approx_{|il|} |its2'|
     \qquad \text{and} \qquad
    |iconf iS2 its2| |.->|^* |iconf iS2' its2'|
    \ \text{.}
  \end{equation}
\end{theorem}

\begin{proof}
  We proof the theorem by induction on the length of the derivation sequence in~(1).
  The base case for derivations
  of length 0 is trivial, allowing
  us to simple chose $|its2'=its2|$ and $|iS2'=iS2|$.  In the step case, we assume
  the theorem holds for derivation sequences of length up to $n$, and show that it also
  holds for those of length $n+1$.  We split the derivation sequence from~(1) as follows:
  \[
  |iconf iS1 its1| |.->| |iconf iS1'' its1''| |.->|^n |iconf iS1' its1'|
  \]
  for some IFC state |iS1''| and task list |its1''|.  By Lemma~1, we get
  |its2''| and |iS2''| with
  \begin{equation} \label{eq:tsni-proof-1}
  |its1''| \approx_{|il|} |its2''|
  \qquad \text{and} \qquad
  |iconf iS2 its2| |.->|^* |iconf iS2'' its2''|
  \end{equation}
  Applying the induction hypotisis to
  $|iconf iS1'' its1''| |.->|^n |iconf iS1' its1'|$, we get |its2'| and |iS2'| with
  \begin{equation} \label{eq:tsni-proof-2}
  |its1'| \approx_{|il|} |its2'|
  \qquad \text{and} \qquad
  |iconf iS2'' its2''| |.->|^* |iconf iS2' its2'|
  \end{equation}
  Stitching together the derivation sequences from (3) and (4) directly gives
  us (2), which concludes the proof.
\end{proof}

\subsection{Generalizing further}

\begin{itemize}
\item Label transition systems.
\item Non-deterministic reduction.
\item Arbitrary scheduling policies $\alpha$
\end{itemize}











