\section{Retrofitting languages with IFC}
\label{sec:retrofit}

Our overall plan will be to take a \textbf{{\color{red} target language}} with a formal
operational semantics and combine it with an \textit{{\color{blue} information
flow control language}}.  For concreteness, we use a simple, untyped,
ML-like language with mutable references as our target language.
However, our technique will be indifferent to the actual target language
chosen: it need only be prepared for interoperability by being expressed
in the style of Matthews and
Findler~\cite{Matthews:2007:OSM:1190216.1190220}.  This procedure will
equip the target language with primitives for implementing dynamic
information control in the style of LIO~\cite{lio}, which we will
describe in more detail shortly.

We have typeset nonterminals of the target language using \textbf{{\color{red}
bold font}} while the nonterminals of the IFC language have been typeset
with \textit{{\color{blue} italic font}}.  Readers are encouraged to view
a color copy of this paper, where target language nonterminals are colored red
while IFC language nonterminals are colored blue.

\subsection{Target language: Mini-ML}

In Figure~\ref{fig:ml}, we give a simple, untyped ML-like language with
mutable references and errors, prepared for combination with an
information flow control language.  The presentation is standard, but it
is worth paying some attention to the Felleisen-Hieb reduction
semantics~\cite{Felleisen:1992:RRS:136293.136297} used to define the
operational semantics of the system.  Our language defines an evaluation
context |tE|; however, the evaluation rules have been expressed in terms
of a different evaluation context $\mathcal{E}_{\tar{\Sigma}}$.  To
derive the usual operational semantics for this language, the evaluation
context merely needs to be defined as |conf tS te @= tS, tE[ te ]|.
However, when we combine this language with an IFC language, we must
reinterpret the meaning of this evaluation context.
In general, we require that a target language be expressed in terms
of some global machine state |tS|, some evaluation context |tE|,
some expressions |te|, some set of values |tv| and a reduction
relations on full configurations $|tS| \times |tE| \times |te|$.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta | unit
te   ::= tv | tx | te te | if te then te else te | ref te | !te | te := te | fail
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE 

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\begin{mathpar}

\and
\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{ }
{| conf tS (ref tv) -> conf (tS [ ta mapsto tv ]) ta |}
{| fresh ta |}

\and
\inferrule[T-deref]
{ }
{| conf tS (!ta) -> conf tS (ap tS ta) |}

\and
\inferrule[T-ass]
{ }
{| conf tS (ta := tv) -> conf (tS [ ta mapsto tv ]) unit |}

\and
\inferrule[T-fail]
{ }
{| conf tS ( tE [ fail ] ) -> conf tS fail |}
\end{mathpar}

\caption{Simple ML-like language |targetLangML|}
\label{fig:ml}
\end{figure}

\subsection{IFC language}

Information flow control seeks to enforce a security policy known as
\emph{non-interference}: public results must not depend on secret inputs.
Modern, dynamic IFC systems usually achieve this by associating a \emph{label}
with data, which encodes a policy of whether or not data tagged with one
label can flow to another label (written as |canFlowTo|).
Since our embedding is agnostic
to the choice of labeling scheme, we simply represent labels with the metavariable
$l$, but do not discuss them in more detail.

In Figure~\ref{fig:ifc}, we give the syntax and \emph{single-threaded}
evaluation rules for a minimal information-flow control language.  The
evaluation context $\mathcal{E}_{\ifc{\Sigma}}$ represents the context
of the current task which is running, including on the right-hand side
the current label $l$ (which protects the program counter of the task)
and the task ID $i$.

Ordinarily, information flow control languages are defined by directly
stating a base language plus information flow control operators.  In
contrast, our language is purposely minimal: it does not have sequencing
operations, control flow, or other constructs.  However, it contains
support for the following core information flow control features:

\begin{itemize}
    \item First-class labels, with label values $l$ as well as operations for computing on
labels (|canFlowTo|, |lub| and |glb|),
    \item operations for inspecting (\textbf{getLabel}) and modifying (\textbf{setLabel}) the current label of the task (a task can only increase its label, and not decrease it),
    \item operations for non-blocking inter-task communication (\textbf{send} and \textbf{recv}),
        which interact with the global store of per-task message queues |iS|, and
    \item a forking operation allowing to spawn new tasks, which will be described in more detail in the next section.
\end{itemize}

The form of \textbf{send}/\textbf{recv} are \Red{inspired by methods of inter-worker communication
in web browser APIs} \Red{cite}, however in Section~\ref{sec:extensions} we
discuss other possible choices for information flow control aware communication
primitives.  Their rules are different from non-IFC systems
and worth commenting on: when a task places
a message on the message queue of receiving task, it also labels that
message with a label |il'| (which must be above the tasks current label |il|)
When the recipient reads out messages from its queue,
messages whose labels do not
flow to |il| are filtered out (denoted by |filter il Q|).
Specifically, if |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|; otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]
This ensures that tasks cannot receive messages that are more secret
than their current label would allow.

%   \begin{figure}
%   Typing judgment: $|tyrule tG tS te tty|$
%   \begin{mathpar}
%   \inferrule[T-ty-address]
%   {}
%   {| tyrule tG tS a (ref (tyLookup tS a)) |}
%   \end{mathpar}

%   \caption{Selected typing rules for ML-like language}
%   \label{fig:ml-typing}
%   \end{figure}

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie
       |  fork ie | send ie ie ie | ix1, ix2 <= recv. ie ie
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | fork iE 
       |  send iE ie ie | send iv iE ie | send iv iv iE
       |  ix1, ix2 <= recv. ie ie
io   ::=  (il, id ie)
Q    ::=  nil | io , Q
iS   ::=  emptyset | iS [ id mapsto Q ]
\end{code}

\begin{mathpar}

\and
\inferrule[I-getLabel]
{ }
{|
niconf iS id il getLabel
->
niconf iS id il il
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
niconf iS id il (setLabel il')
->
niconf iS id il' unit
|}
%{|fresh (id')|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
}
{|
niconf iS  id il (send id' il' ie)
->
niconf iS' id il unit
|}

\and
\inferrule[I-recv]
{
| filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
| iS' = iS[id mapsto io1 , ... , iok]|\\
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ({ie'/ix1,id'/ix2} ie1)
|}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = iS[id mapsto nil]|
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ie2
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |niconf iS id il (il1 lop il2) -> niconf iS id il iv| }
\end{mathpar}
\caption{IFC language with all single-threaded operations}
\label{fig:ifc}
\end{figure}

\subsection{The embedding}

\Red{TODO[ds]:
  - move the async recv to text and out of the figure
  - clarify discussion on exceptions
  - fix the toLabled
  - add taskIDs to ruls
}
Finally, in Figure~\ref{fig:embedding},
we provide all of the rules responsible for actually carrying out the embedding.
The most important feature of this embedding is that every task maintains its own
copy of the target language global state and evaluation context, thus
enforcing isolation between various tasks.  In more detail:

\begin{figure}
%{
%format .->  = "\overset{\alpha}{\hookrightarrow}"
%format .-/>  = "\not\overset{\alpha}{\hookrightarrow}"
\begin{tabular}{ll}
\begin{minipage}{.22\textwidth}
\begin{code}
iv  ::= cdots | IT tv
ie  ::= cdots | IT te
iE  ::= cdots | IT tE
\end{code}
\end{minipage} &
\begin{minipage}{.22\textwidth}
\begin{code}
tv  ::= cdots | TI iv
te  ::= cdots | TI ie
tE  ::= cdots | TI iE
\end{code}
\end{minipage}
\end{tabular}

\begin{code}
ix1, ix2 <= brecv . ie @=
tab tab tab (IT (let tx = TI (ix1, ix2 <= recv. ie  (IT tx)) in tx))
conf tS te @= iconf iS (fullconf id il tS (iniEt te), ldots)
niconf iS id il ie @= iconf iS (fullconf id il tS (iniEi ie), ldots)
CE[e] -> iconf iS (it, ldots) @= CE[e] .-> iconf iS (sched step (it, ldots))
\end{code}

\begin{mathpar}
\inferrule[I-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|tS' = klone(tS)|\\
|it1 = fullconf id il tS (iniE id')|\\
|itnew = fullconf id' il tS' (TI ie)|\\
|fresh (id')|
}
{|
iconf iS (fullconf id il tS (iniEi (fork ie)), ldots)
.->
iS'; sched F (it1, ldots, itnew)
|}

\and
\inferrule[I-done]
{|
|}
{|
iconf iS (fullconf id il tS iv, ldots)
.->
iS ; sched D (fullconf id il tS iv, ldots)
|}

\and
\inferrule[I-noStep]
{|
iconf iS (it, ldots) .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched N (it, ldots)
|}

\and
\inferrule[I-border]
{ }
{|
niconf iS id il (IT (TI (ie)))
->
niconf iS id il ie
|}

\and
\inferrule[T-border]
{ } {| conf tS (TI (IT (te))) -> conf tS te|}
\end{mathpar}
\caption{The embedding |specLang alpha (targetLang nop)|, where
|targetLang nop = (tS, tE, te, tv, ->)|}
\label{fig:embedding}
%}
\end{figure}

\begin{figure}
  Concurrent, round robin:
\begin{code}
  roundrobin step (it1, it2, ldots)  = it2, ldots, it1
  roundrobin D (it1, it2, ldots)     = it2, ldots
  roundrobin N (it1, it2, ldots)     = it2, ldots
  roundrobin F (it1, it2, ldots)     = it2, ldots, it1
\end{code}
  Sequential:
\begin{code}
  seq step (it1, it2, ldots)     = it1, it2, ldots
  seq N (it1, it2, ldots)        = it1, it2, ldots
  seq D (it)                     = it
  seq D (it1, it2, ldots)        = it2, ldots
  seq F (it1, it2, ldots, itn)   = itn, it1, it2, ldots
\end{code}
\caption{Scheduling policies}
\label{fig:scheduler}
\end{figure}

\begin{itemize}
    \item We extend the values, expressions and evaluation contexts of both languages to allow for embeddings terms in one language to be embedded in the other.
    \item We reinterpret |CE| to be evaluation contexts on task pools, providing definitions for $\mathcal{E}_{\tar{\Sigma}}$ and $\mathcal{E}_{\ifc{\Sigma}}$.  These rules only operate on the first task in the task pool, which by convention, is the only task executing.
    \item We reinterpret |->|, an operation on a single task, in terms of |.->|, operation on task pools.  The correspondence is simple: a task executes a step and then is rescheduled in the task pool according to schedule policy $\alpha$.  Not all schedulers preserve non-interference, so we provide two specific schedules in Figure~\ref{fig:scheduler}.
    \item Finally, we define some rules for scheduling, handling forking tasks (which interact with the state of the target language) and intermediating between the borders of the two languages.
\end{itemize}

The \textsc{I-fork} rule is of particular interest, as it is intended to allow users
to create new tasks.  When a new task is created, there is a question of what the
global state of the new task should be; this is defined in terms of a function $\kappa$.
Conservatively, $\kappa$ may be simply thought of as the identity function, in which
case the semantics of fork are such that the state of the target language is \emph{cloned}
when forking occurs.  However, this is not necessary: it is also valid for $\kappa$
to remove entries from the state.  In Section~\ref{sec:concrete}, we give a more detailed
discussion of the implications of the choice of $\kappa$.

\subsection{Examples}

To get a feeling for how these operational semantics operate, we'd like to
describe a few sample programs, and what their outputs are.

\paragraph{Sending mutable references}  As each task maintains its own
global state for the target language, one might reasonably wonder what would
happen if you attempted to send a reference to another task.

\begin{align*}
    & |let i = TI (fork (x, i' <= brecv . (IT (!(TI x)))))| \\
    & |in TI (send (IT (ref true)))|
\end{align*}

It would be a violation of information flow if such an operation actually
resulted in references being shared between two tasks.  In fact, the address
will be received by the forked task, but it will be a dangling pointer; the
task will become stuck and removed from execution by \textsc{I-noStep}.  (Readers
who are curious whether or not a static discipline could be enforced to
prevent these dangling pointers should check Section~\ref{sec:extensions}.)

\paragraph{Status of the heap after a fork}  Here is a program whose
semantics depends on the definition of $\kappa$:

\begin{align*}
    & |let x = ref true| \\
    & |in TI (fork (IT (!x; !x))); x := false|
\end{align*}

When $\kappa$ is the identity, the forked task successfully dereferences
the contents of the reference to be true twice (recall that references
are cloned into the new global state).  When $\kappa$ is the constant function
to the empty store, $x$ becomes a dangling pionter.

\paragraph{Exceptions}  One language feature that has caused difficulty
for many information flow control systems is handling
exceptions.~\cite{Hritcu:2013:YIB:2497621.2498098}  The key difficulty
appears when an exception must cross a stack boundary where the current
label reverts back, i.e. across a \textbf{toLabeled} operator.~\cite{lio}
If the exception crosses this boundary, it can leak information about the
inner sensitive computation.

At first glance, it does not appear that our system has any such operator;
there are only tasks, and the correct behavior for a task throwing
an exception is self-evident: it should simply be removed from the scheduler.
However, under a \emph{sequential scheduler}, the behavior of \textbf{fork}
can be used to model the behavior of \textbf{toLabeled}:

\begin{align*}
    & |toLabeled l te @= | \\
    & |tab let pid = taskId; | \\
    & |tab let i = TI (fork (IT (TI (setLabel l); TI (send pid l (IT te)))))| \\
    & |tab in (\ _ . TI (setLabel l); TI ( x, _ <= recv . x ))| \\
\end{align*}

When the sequential scheduler is used, the forked task runs to
completion before returning to the task that forked it.  Thus,
a task pool should rather be interpreted as a number of information-flow
aware stack frames.  To read the result of a |toLabeled| operation
(which is communicated via message passing), the parent task must raise
its label; otherwise the label will get dropped, as per the \textsc{I-recv} rule.\footnote{A keen reader may note that with a single, per-task
channel, we might mix up our messages.  Indeed, a proper development requires
the ability to allocate fresh channels; for purposes of simplicity, this
has been omitted.}

In this setting, it is also clear that exceptions should not cross boundaries,
as seen in |toLabeled l fail; true|, which evaluates to |true| no matter even in
the event of an exception inside of the |toLabeled| block:

%   \Red{When both languages have booleans, it is relatively simple to define
%   a natural embedding which preserves booleans across boundaries.}
%   \begin{mathpar}
%   \inferrule[I-bool]
%   { |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
%   \and
%   \inferrule[T-bool]
%   { |b member {true, false}| } {| intE (TI b) -> intE b |}
%   \end{mathpar}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
