\section{Retrofitting languages with IFC}
\label{sec:retrofit}

While we would like to add information flow control to \emph{any}
language, we will have to make some assumptions about the form of the
target language.  We consider languages whose semantics can be expressed
in the form of abstract machines |(tS, tE, te, tv, ->)|, where |tS| is the
global machine state, |tE| is an evaluation context, |te| is an
expression in the language, |tv| is the set of values, and |->| is the reduction relation on such
configuration, i.e., $|->| : (|tS| \times |tE| \times |te|)
\rightharpoonup (|tS| \times |tE| \times |te|)$.  Metavariables in this
target language have been colored red.

In Figure~\ref{fig:ml}, we give an example of a standard ML-like
language with mutable references.  These semantics have been prepared
for interoperability in the style of Matthews and Findler~\Red{XXX}; in
particular, the evaluation rules have been expressed in terms of an
evaluation context $\mathcal{E}_{\tar{\Sigma}}$.  Without the embedding,
this evaluation context is defined as |conf tS te @= tS, tE[ te ]|, but
when we perform the embedding, we will reinterpret the meaning
of this evaluation context, lifting these semantics to an IFC setting.

\begin{figure}
\begin{code}
tv   ::= \tx.te | true | false | ta
tty   ::= bool | tty -> tty | ref tty
te   ::= tv | tx | te te | if te then te else te | ref te | !te | te := te
tE   ::= tHole | tE te | tv tE | if tE then te else te
       | ref tE | !tE | tE := te | tv := tE 

te1 ; te2            @= (\tx.te2) te1  where  tx notmember FV(te2)
let tx = te1 in te2  @= (\tx.te2) te1
\end{code}

\Red{Suggestion: Only give the rules for references, because otherwise this is all standard.}

\begin{mathpar}

\and
\inferrule[T-app]
{ } {| conf tS ((\x.te) tv) -> conf tS ({tv/x} te) |}

\and
\inferrule[T-ifTrue]
{ } {| conf tS (if true then te1 else te2) -> conf tS te1|}

\and
\inferrule[T-ifFalse]
{ } {| conf tS (if false then te1 else te2) -> conf tS te2|}

\and
\inferrule[T-ref]
{| tS' = tS [ ta mapsto tv ] | } 
{| conf tS (ref tv) -> conf tS' ta |}
{| fresh (ta) |}

\and
\inferrule[T-deref]
{| tv = tS(ta) |}
{| conf tS (!ta) -> conf tS tv |}

\and
\inferrule[T-ass]
{| tS' = tS [ ta mapsto tv ] |} 
{| conf tS (ta := tv) -> conf tS' tv |}
\end{mathpar}

\caption{Simple ML-like language}
\label{fig:ml}
\end{figure}

Next, we describe the IFC language.  \Red{Description of the IFC language as
a standard floating label system, or backwards reference to the
background section.}  In Figure~\ref{fig:ifc}, we describe the syntax
of the language, and provide rules for all operations which operate on a single
thread.  \Red{One could imagine these rules giving the definition of a very
boring information flow control language, by defining |niconf iS id il ie| appropriately
and providing an appropriate erasure function.}

We use the notation |filter il Q| to indicate a filter function which removes message whose labels do not
flow to |il|. Specifically, if |Q| is the empty list |nil|, the
function is simply the identity function, i.e.,
|filter il nil = nil|; otherwise:
\[
|filter il ((il', id, ie) , Q )| = \left\{
\begin{array}{l l}
|(il', id, ie) , filter il Q| & \quad \text{if |il' canFlowTo il|}\\
|filter il Q| & \quad \text{otherwise}
\end{array} \right.
\]

%   \begin{figure}
%   Typing judgment: $|tyrule tG tS te tty|$
%   \begin{mathpar}
%   \inferrule[T-ty-address]
%   {}
%   {| tyrule tG tS a (ref (tyLookup tS a)) |}
%   \end{mathpar}

%   \caption{Selected typing rules for ML-like language}
%   \label{fig:ml-typing}
%   \end{figure}

\begin{figure}
\begin{code}
lop  ::=  canFlowTo | lub | glb
iv   ::=  id | il | true | false | unit
ie   ::=  iv | ix | ie lop ie | getLabel | setLabel ie
       |  fork ie | send ie ie ie | ix1, ix2 <= recv. ie ie
iE   ::=  iHole | iE lop ie | iv lop iE | setLabel iE | fork iE 
       |  send iE ie ie | send iv iE ie | send iv iv iE
       |  ix1, ix2 <= recv. ie ie
io   ::=  (il, id ie)
Q    ::=  nil | io , Q
iS   ::=  emptyset | iS [ id mapsto Q ]
\end{code}

\begin{mathpar}

\and
\inferrule[I-getLabel]
{ }
{|
niconf iS id il getLabel
->
niconf iS id il il
|}

\and
\inferrule[I-setLabel]
{ |il canFlowTo il'| }
{|
niconf iS id il (setLabel il')
->
niconf iS id il' unit
|}
%{|fresh (id')|}

\and
\inferrule[I-send]
{
|il canFlowTo il'|\\
|iS(id') = Q|\\
|iS' = iS [ id' mapsto (il', id,  ie) , Q ]|
}
{|
niconf iS  id il (send id' il' ie)
->
niconf iS' id il unit
|}

\and
\inferrule[I-recv]
{
| filter il (iS(id)) = io1 , ... , iok , (il', id', ie')|\\
| iS' = iS[id mapsto io1 , ... , iok]|\\
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ({ie'/ix1,id'/ix2} ie1)
|}

\and
\inferrule[I-noRecv]
{
| filter il (iS(id)) = nil|\\
| iS' = iS[id mapsto nil]|
}
{|
niconf iS  id il (ix1, ix2 <= recv. ie1 ie2)
->
niconf iS' id il ie2
|}

\inferrule[I-labelOp]
{ |denot (il1 lop il2) = iv|}
{ |niconf iS id il (il1 lop il2) -> niconf iS id il iv| }
\end{mathpar}
\caption{IFC language, single-thread operations}
\label{fig:ifc}
\end{figure}

Finally, in Figure~\ref{fig:embedding},
we provide all of the rules responsible for actually carrying out the embedding:

\begin{itemize}
    \item We extend the values, expressions and evaluation contexts of both languages to allow for embeddings terms in one language to be embedded in the other.  \Red{For now, we defer discussion on how these boundaries mediate between the type systems of the two languages.}
    \item We reinterpret |CE| to be evaluation contexts on threadpools.  By assumption, only the first thread in the threadpool executes.
    \item We define |->|, operation on a single thread, in terms of |.->|, operation on thread pools.  The correspondence is simple: a thread executes a step, and then is rescheduled in the thread pool according to schedule policy $\alpha$. \Red{More on schedule policies later}
    \item Finally, we define some rules for scheduling, handling forking threads (which interact with the state of the target language) and intermediating between the borders of the two languages. \Red{As written, these rules will not preserve type-safety of the underyling language, but it is easy to adjust them to ensure they do so.}
\end{itemize}

The fork rule is of particular interest; it is defined in terms of a function $\kappa$.
Conservatively, $\kappa$ may be simply thought of as the identity function, in which
case the semantics of fork are such that the state of the target language is \emph{cloned}
when forking occurs.  However, this is not necessary: it is also valid for $\kappa$
to remove entries from the state.  \Red{For more information about when this is not the
fork semantics you want, see the concrete implementation section.}

\begin{figure}
\begin{tabular}{ll}
\begin{minipage}{.22\textwidth}
\begin{code}
iv  ::= cdots | IT tv
ie  ::= cdots | IT te
iE  ::= cdots | IT tE
\end{code}
\end{minipage} &
\begin{minipage}{.22\textwidth}
\begin{code}
tv  ::= cdots | TI iv
te  ::= cdots | TI ie
tE  ::= cdots | TI iE
\end{code}
\end{minipage}
\end{tabular}

\begin{code}
ix1, ix2 <= brecv . ie @= IT (let tx = TI (ix1, ix2 <= recv. ie  (IT tx)) in tx)
conf tS te @= iconf iS (fullconf id il tS (iniEt te), ldots)
niconf iS id il ie @= iconf iS (fullconf id il tS (iniEi ie), ldots)
CE[e] -> iconf iS (it, ldots) @= CE[e] .-> iconf iS (sched step (it, ldots))
\end{code}

\begin{mathpar}
\and
\inferrule[I-fork]
{ 
|iS' = iS [ id' mapsto nil ]|\\
|tS' = klone(tS)|\\
|it1 = fullconf id il tS (iniE id')|\\
|itnew = fullconf id' il tS' (TI ie)|\\
|fresh (id')|
}
{|
iconf iS (fullconf id il tS (iniEi (fork ie)), ldots)
.->
iS'; sched F (it1, ldots, itnew)
|}

\and
\inferrule[I-done]
{|
|}
{|
iconf iS (fullconf id il tS iv, ldots)
.->
iS ; sched D (fullconf id il tS iv, ldots)
|}

\and
\inferrule[I-noStep]
{|
iconf iS (it, ldots) .-/> 
|}
{|
iconf iS (it, ldots)
.->
iS ; sched N (it, ldots)
|}

\and
\inferrule[I-border]
{ }
{|
niconf iS id il (IT (TI (ie)))
->
niconf iS id il ie
|}

\and
\inferrule[T-border]
{ } {| conf tS (TI (IT (te))) -> conf tS te|}
\end{mathpar}
\caption{The embedding}
\label{fig:embedding}
\end{figure}


\begin{figure}
\begin{align*}
  &|erase il (iconf iS its) =
  iconf (erase il iS) (fltr (\ it . it = bullet) (map (erasef il) its))| \\
  &|erase il (tconf id il' ie) =| \begin{cases}
    %|lconf bullet bullet bullet bullet| & |il' cantFlowTo il| \\
    |bullet| & |il' cantFlowTo il| \\
    |tconf id il' ie| & \text{otherwise}
  \end{cases} \\
  &|erase il emptyset = emptyset|\\
  &|erase il (iS [id mapsto Q]) =| \begin{cases}
    |erase il iS| & \text{|il' cantFlowTo il|, where |il'| is}\\
    & \text{the label of thread |id|} \\
    |(erase il iS) [id mapsto (erase il Q)]| & \text{otherwise}
  \end{cases} \\
  &|erase il Q = filter il Q|
\end{align*}
\caption{
Erasure function for configurations, threads, system state, and
message queus.  In all other cases, |erasef il| is applied
homomorphically.
\label{fig:erasure}
}
\end{figure}

\Red{When both languages have booleans, it is relatively simple to define
a natural embedding which preserves booleans across boundaries.}
\begin{mathpar}
\inferrule[I-bool]
{ |b member {true, false}|  } {| iniE (IT b) -> iniE b |}
\and
\inferrule[T-bool]
{ |b member {true, false}| } {| intE (TI b) -> intE b |}
\end{mathpar}

\begin{figure}
  Concurrent, round robin:
\begin{code}
  roundrobin step (it1, it2, ldots)  = it2, ldots, it1
  roundrobin D (it1, it2, ldots)     = it2, ldots
  roundrobin N (it1, it2, ldots)     = it2, ldots
  roundrobin F (it1, it2, ldots)     = it2, ldots, it1
\end{code}
  Sequential:
\begin{code}
  seq step (it1, it2, ldots)     = it1, it2, ldots
  seq N (it1, it2, ldots)        = it1, it2, ldots
  seq D (it)                     = it
  seq D (it1, it2, ldots)        = it2, ldots
  seq F (it1, it2, ldots, itn)   = itn, it1, it2, ldots
\end{code}
\caption{Scheduling policies}
\end{figure}


\clearpage % TODO: remove again, but keep for now to not have the text be split across 4 pages.
\subsection{Formal Guarantees}

\begin{definition}[Information-flow control language]
    An information-flow control language |L| is a tuple $(|C|, |C|^*, |.->|,
    |erasef l|)$, where $c \in |C|$ is the type of machine configurations,
    $|C|^*$ is the type of erased machine configurations, |.->| is a
    reduction relation between machine configurations and $|erasef l|$
    is an erasure function from machine configurations to erased machine
    configurations.  For sequential languages, we may also speak of
    values, e.g. a configurations $V \subseteq |C|$ for which there are
    no possible further transitions.
\end{definition}

\begin{definition}[$l$-equivalence]
    Two machine configurations $c$ and $c'$ are considered $l$-equivalent ($c \approx_l c'$)
    if $|erase l c| = |erase l c'|$.
\end{definition}

\begin{definition}[Termination Sensitive Non-Interference (TSNI)]
  A language $|L|=(|C|, |C|^*, |.->|, |erasef l|)$ is termination
  sensitive non-interfering if for any label |l|, and configurations
  |c1, c1', c2 member C|, if
  \begin{equation} \label{eq:tsni-lhs}
    |c1| \approx_{|l|} |c2|
    \qquad \text{and} \qquad
    |c1| |.->|^* |c1'|
  \end{equation}
  then there exists a configuration |c2' member C| such that
  \begin{equation} \label{eq:tsni-rhs}
    |c1'| \approx_{|l|} |c2'|
     \qquad \text{and} \qquad
    |c2| |.->|^* |c2'|
    \ \text{.}
  \end{equation}
\end{definition}


\begin{theorem}[TSNI]
\end{theorem}

\begin{lemma}
  \label{lemma:tsni}
  For any configurations |ic1|, |ic1'|, |ic2|, and label |il| where
  \begin{equation} \label{eq:tsni-lemma-lhs}
  |ic1| \approx_{|il|} |ic2|
  \qquad \text{and} \qquad
  |ic1| |.->| |ic1'|
  \end{equation}
  then there exists a configuration |ic2'| such that
  \begin{equation} \label{eq:tsni-lemma-rhs}
  |ic1'| \approx_{|il|} |ic2'|
  \qquad \text{and} \qquad
  |ic2| |.->|^* |ic2'|
  \ \text{.}
  \end{equation}
\end{lemma}

\begin{proof}
  We proof the theorem by induction on the length of the derivation sequence in~\eqref{eq:tsni-lhs}.
  The base case for derivations
  of length 0 is trivial, allowing
  us to simple chose $|ic2'=ic2|$.  In the step case, we assume
  the theorem holds for derivation sequences of length up to $n$, and show that it also
  holds for those of length $n+1$.  We split the derivation sequence from~\eqref{eq:tsni-lhs} as follows:
  \[
  |ic1| |.->| |ic1''| |.->|^n |ic1'|
  \]
  for some configuration |ic1''|.  By Lemma~\ref{lemma:tsni}, we get
  |ic''| with
  \begin{equation} \label{eq:tsni-proof-1}
  |ic1''| \approx_{|il|} |ic2''|
  \qquad \text{and} \qquad
  |ic2| |.->|^* |ic2''|
  \end{equation}
  Applying the induction hypothesis to
  $|ic1''| |.->|^n |ic1'|$, we get |ic2'| with
  \begin{equation} \label{eq:tsni-proof-2}
  |ic1'| \approx_{|il|} |ic2'|
  \qquad \text{and} \qquad
  |ic2''| |.->|^* |ic2'|
  \end{equation}
  Stitching together the derivation sequences from~\eqref{eq:tsni-proof-1} and~\eqref{eq:tsni-proof-2} directly gives
  us~\eqref{eq:tsni-rhs}, which concludes the proof.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lemma:tsni}]
  We proof the lemma by induction on the derivation
  for~\eqref{eq:tsni-lemma-lhs}, and consider all possible rules that
  could have been used to make the reduction step.
  First, we observe there must be at least one task in |ic1|, otherwise
  it could not take a step.  Thus, |ic1| is of the form
  |iconf iS1 (it1, its1)|.  Consider two cases:
  \begin{itemize}
    \item $|erase il it1|=|bullet|$. In this case, we do not need to take a
    step for
    |ic2|, because |ic2'=ic2| will already be |il|-equivalent to |ic1'|.
    To see that, note that the tasks |its1| in |ic1| are left in the
    same order and unmodified. The task |it1| either
    gets dropped (by \textsc{I-noStep}), or
    transforms into a new task |it1'| as well as potentially spawning a new
    task |it1''|.  Since both |it1'| and |it1''| have a label that is
    at least as high as the label of |it1|, they will get filtered
    by |erasef il| in |ic1'|.
    Lets consider the possible changes to |iS1|: If |it1| sends a
    message, then the corresponding queue in |iS1'| will contain one
    more message.  However, that message has the label of |it1| (or a higher
    label), and will thus get erased by |erasef il|.
    Finally, receiving or not receiving a message (by
    \textsc{I-recv} or \textsc{I-noRecv}) only changes the queue of
    task |it1|, which are erased from |iS1|.
    This ensures that $|ic1'|\approx_{|il|}|ic2'|$.
    
    \alphacondition{We need all scheduling policies to not change the order
      of any tasks (except for the first one).  Newly spawned task can appear
      anywhere in the list.}
    \item $|erase il it1|\neq|bullet|$.  Here, there must be a corresponding
    task |it2| in |ic2|,
    such that |it1=it2| (otherwise |ic1| and
    |ic2| could not be |il| equivalent).
    However, |it2| might not be at the beginning of the task list yet, but
    all tasks occurring before it must get erased by |erasef il|.
    In |ic2|, we can first take some number of steps until |it2| moves
    to the front of the list (\Red{Say more precisely why
      (basically because we require the scheduling policy to do that)}).
    
    \alphacondition{The scheduling policy must eventually let any task in
      the task list evaluate.  In particular, it cannot get stuck when the
      first task gets stuck, or keep executing a small number of tasks
      exclusively forever (e.g. just execute the first task all the time
      if it gets into an infinite loop).}
    
    Therefore, after |ic2| has potentially executed some number of steps
    to arrive at |ic2''|, we are now in the situation where $|ic1|\approx_{|il|}|ic2''|$, and the first task |it1| and |it2| don't
    get erased and are thus equivalent.
    The task |it2| can now take exactly the same step as |it1|;  we only
    need to argue that the potential differences in |iS1| and |iS2| cannot
    have an influence on the execution (and we know |iS1| and |iS2| are
    |il| equivalent).
    Again, only send and receive will change |iS|, so we consider all
    rules that could have been used for~\eqref{eq:tsni-lemma-rhs}.  If
    a message is sent, then the message is added to the same queue.  This
    queue is either completely erased, or it is |il| equivalent.  In both
    cases, |il| equivalence of |iS1'| and |iS2'| is preserved.
    When the tasks are receiving a message, then by the reduction rules
    we know that they first filter the queue by the label of |it1|.  We
    also know that the queues are equivalent when filtered by the less
    restrictive label |il|, thus the messages received (or dropped) from the
    queue are equivalent.
  \end{itemize}
\end{proof}

\begin{definition}[Termination Insensitive Non-Interference (TINI)]
  A language $|L|=(|C|, |C|^*, |.->|, |erasef l|)$ is termination
  insensitive non-interfering if for any label |l|, and configurations
  |c1, c2, V1, V2 member C|, if
   $|c1| \approx_{|l|} |c2|$,
   $|c1| |.->|^* |V1|$, and
   $|c2| |.->|^* |V2|$, then
   $|V1| \approx_{|l|} |V2|$.
\end{definition}


\begin{theorem}[Termination Insensitive Non-Interference (TINI)]
  For any label |il| and configurations |ici = iconf iSi iti|, |ici' =
  iconf iSi' (fullconf idi ili tSi' ivi')|, where |i member {1,2}|, if
   $|ic1| \approx_{|il|} |ic2|$,
   $|ic1| |.->|^* |ic1'|$, and
   $|ic2| |.->|^* |ic2'|$, then
   $|ic1'| \approx_{|il|} |ic2'|$.
\end{theorem}



\subsection{Generalizing further}

\begin{itemize}
\item Label transition systems.
\item Non-deterministic reduction.
\item Arbitrary scheduling policies $\alpha$
\end{itemize}











